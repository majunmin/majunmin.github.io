{"name":"go","slug":"go","count":2,"postlist":[{"title":"go build 实现包切换","uid":"d96ad83bba94948fc2ba2a5f3d6fbcb0","slug":"go-build-实现包切换","date":"2022-08-03T04:18:02.000Z","updated":"2022-09-03T07:45:16.171Z","comments":true,"path":"api/articles/go-build-实现包切换.json","keywords":null,"cover":null,"text":"参考 Gin 的实现 gin 在 internal/json包中实现了多个 json 包的序列化能力, 默认使用官方encoding/json包. 如何保证这些包不会冲突呢? 这里用到了 go build -tags 的能力. [json.go](https://github.c...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"go","slug":"go","count":2,"path":"api/tags/go.json"},{"name":"go build","slug":"go-build","count":1,"path":"api/tags/go-build.json"}],"author":{"name":"majm","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"技术分享","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"fastcache源码分析","uid":"e948586c90ca41ff51fdf8e035fa5502","slug":"fastcache源码解析","date":"2023-05-06T07:52:35.000Z","updated":"2023-05-06T07:52:35.049Z","comments":true,"path":"api/articles/fastcache源码解析.json","keywords":null,"cover":[],"text":"fastcache 特性: 快速, 高性能, 多 CPU上 可扩展 线程安全. 多个 goroutine 可以同时读写一个cache 实例 fastcache 设计为 在存储大量的 entry 的场景下 GC free fastcache 当 缓存数量达到阈值时 可以自动 清理 ...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[],"tags":[{"name":"go","slug":"go","count":2,"path":"api/tags/go.json"},{"name":"cache","slug":"cache","count":3,"path":"api/tags/cache.json"},{"name":"fastcache","slug":"fastcache","count":1,"path":"api/tags/fastcache.json"}],"author":{"name":"majm","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"技术分享","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}]}