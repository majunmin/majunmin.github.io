{"title":"Mysql索引原理","uid":"ce52f41a783fc1c1eec924862c197938","slug":"Mysql索引原理","date":"2019-06-12T14:18:19.000Z","updated":"2022-03-03T15:51:13.983Z","comments":true,"path":"api/articles/Mysql索引原理.json","keywords":null,"cover":[],"content":"<h2 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>在系统中，为了提高查询性能，<br>这里 主要记录 InnoDB存储引擎的索引，<br>InnoDB 支持一下几种常见的索引 <code>B+Tree索引</code>  <code>全文索引</code>  <code>Hash索引</code></p></blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"为什么要有索引？\"><a href=\"#为什么要有索引？\" class=\"headerlink\" title=\"为什么要有索引？\"></a>为什么要有索引？</h2><p>索引在MySQL中也叫做 <code>键</code>，是存储引擎用于快速找到记录的一种数据结构。索引对于良好的性能非常关键，<br>尤其是当表中的数据量越来越大时，索引对于性能的影响愈发重要。<br>索引优化应该是对查询性能优化最有效的手段了。索引能够轻易将查询性能提高好几个数量级。</p>\n<h2 id=\"索引的数据结构\"><a href=\"#索引的数据结构\" class=\"headerlink\" title=\"索引的数据结构\"></a>索引的数据结构</h2><p>任何一种数据结构都不是凭空产生的，一定会有它的背景和使用场景，我们现在总结一下，我们需要这种数据结构能够做些什么，其实很简单，那就是：每次查找数据时把<code>磁盘IO次</code>数控制在一个很小的数量级，最好是常数数量级。那么我们就想到如果一个高度可控的多路搜索树是否能满足需求呢？ –&gt; <code>B+树</code> 应运而生。</p>\n<p><img src=\"/post/Mysql%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/%E4%B8%80%E6%A3%B5%E9%AB%98%E5%BA%A6%E4%B8%BA2%E7%9A%84B+Tree.jpg\" alt=\"一棵高度为2的B+Tree.jpg\"></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>叶子节点通过双向链表进行连接</p></blockquote>\n<h3 id=\"B-Tree的查找过程\"><a href=\"#B-Tree的查找过程\" class=\"headerlink\" title=\"B+Tree的查找过程\"></a>B+Tree的查找过程</h3><p><img src=\"/post/Mysql%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/B+Tree.png\"></p>\n<p>浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示），如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。</p>\n<p>如图所示，如果要查找数据项<code>29</code>，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计<code>三次IO</code>。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，<br>如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高. </p></blockquote>\n<h3 id=\"B-Tree-性质\"><a href=\"#B-Tree-性质\" class=\"headerlink\" title=\"B+Tree 性质\"></a>B+Tree 性质</h3><ol>\n<li><p><strong>索引字段要尽量的小</strong>(树的高度越低,IO次数就少):通过上面的分析，我们知道IO次数取决于b+数的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h&#x3D;㏒(m+1)N，当数据量N一定的情况下，m越大，h越小；而m &#x3D; 磁盘块的大小 &#x2F; 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比 <code>bigint</code> 8字节少一半。这也是为什么 <code>B+Tree</code> 要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。</p>\n</li>\n<li><p><strong>索引的最左匹配特性(即从左往右匹配)</strong>:当 B+Tree 的数据项是复合的数据结构，比如<code>idx_name_age_sex(name,age,sex)</code>的时候，B+Tree 是按照从左到右的顺序来建立搜索树的，比如当<code>(张三,20,F)</code>这样的数据来检索的时候，B+Tree 会优先比较 <code>name</code> 来确定下一步的所搜方向，如果 <code>name</code> 相同再依次比较 <code>age</code> 和 <code>sex</code>，最后得到检索的数据；但当<code>(20,F)</code>这样的没有<code>name</code>的数据来的时候，B+Tree 就不知道下一步该查哪个节点，因为建立搜索树的时候 <code>name</code> 就是第一个比较因子，必须要先根据 <code>name</code> 来搜索才能知道下一步去哪里查询。比如当<code>(张三,F)</code>这样的数据来检索时，B+Tree 可以用 <code>name</code> 来指定搜索方向，但下一个字段 <code>age</code> 的缺失，所以只能把名字等于<code>张三</code>的数据都找到，然后再匹配性别是<code>F</code>的数据了， 这个是非常重要的性质，即索引的<code>最左匹配特性</code>。</p>\n</li>\n</ol>\n<h2 id=\"索引的类型\"><a href=\"#索引的类型\" class=\"headerlink\" title=\"索引的类型\"></a>索引的类型</h2><ul>\n<li>B+Tree 索引(innoDB 默认支持的索引)</li>\n<li>Hash索引<br>hash类型的索引: 查询单条快，范围查询慢<br>B+Tree类型的索引: B+Tree,层数越多,数据量指数级增长（我们就用它，因为<code>innodb</code>默认支持它）</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#不同的存储引擎支持的索引类型也不一样\nInnoDB 支持事务，支持行级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引；\nMyISAM 不支持事务，支持表级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引；\nMemory 不支持事务，支持表级别锁定，支持 B-tree、Hash 等索引，不支持 Full-text 索引；\nNDB 支持事务，支持行级别锁定，支持 Hash 索引，不支持 B-tree、Full-text 等索引；\nArchive 不支持事务，支持表级别锁定，不支持 B-tree、Hash、Full-text 等索引；<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n<h3 id=\"B-Tree-索引\"><a href=\"#B-Tree-索引\" class=\"headerlink\" title=\"B+Tree 索引\"></a>B+Tree 索引</h3><p><code>B+Tree</code> 索引 是 B+Tree 在数据库中的实现，但是 <code>B+tree</code> 索引在数据库中有一个特点是高扇出性，因此在数据库中， <code>B+Tree</code> 的高度一般在 2-4 层.<br>数据库中 <code>B+Tree</code> 索引一般可以分为 <code>聚簇索引(cluster index)</code> 和 <code>辅助索引(secondary index)</code>,但是不管是<code>聚簇索引 </code>还是 <code>辅助索引</code>，其内部都是<code>B+Tree</code>， 即高度平衡的，叶子节点存放着所有的数据。 <code>聚簇索引</code> 与 <code>辅助索引</code>不同的是叶子节点存放的是一整行的数据。</p>\n<h3 id=\"聚簇索引\"><a href=\"#聚簇索引\" class=\"headerlink\" title=\"聚簇索引\"></a>聚簇索引</h3><p>InnoDB 存储引擎表是索引组织表， 即表中数据按照主键顺序存放。 而<code>聚簇索引(cluster index)</code>就是按照每张表的主键构造一颗 <code>B+Tree</code> 同时叶子节点存放的是整张表的行记录数据。也将聚簇索引的叶子节点称为数据页。<code>聚簇索引</code>的这个特性决定了索引组织表中数据也是索引表的一部分，同 <code>B+Tree</code> 数据结构一样，每个数据页都通过一个双向链表进行连接。</p>\n<p>由于实际数据页只能按照一课B+Tree 进行排序，因此每张表只能有一个聚簇索引。 大多数情况下，查询优化器倾向于采用聚簇索引。因为聚簇索引能够在叶子节点上直接查找到数据。此外，由于定义了数据的逻辑顺序，聚簇索引能够很快的访问针对范围值的查询。查询优化器能够快速的发现这一范围的数据页需要扫描。</p>\n<h3 id=\"辅助索引\"><a href=\"#辅助索引\" class=\"headerlink\" title=\"辅助索引\"></a>辅助索引</h3><p>对于<code>辅助索引(secondary Index)</code>, 叶子节点并不包含航记录的全部数据。 叶子节点除了包含键值以外，每个叶子节点的中的所银行中还包含了一个<code>书签(bookMark)</code>。 该 bookMark 用来告诉<code>InnoDB 存储引擎</code>可以在哪里找到与索引相对应的行数据。由于INnoDB存储引擎表是索引组织表，因此 InnoDB 存储引擎的<code>辅助索引的书签</code>就是相应的行数据的<code>聚簇索引键</code>。<br>下图显示了 <code>InnoDB</code>中 <code>聚簇索引</code> 与 <code>辅助索引的</code>关系。<br><img src=\"/post/Mysql%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E4%B8%8E%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95%E7%9A%84%E5%85%B3%E7%B3%BB.jpg\" alt=\"聚簇索引与辅助索引的关系\"></p>\n<p>辅助索引的存在并不影响数据在聚簇索引中的组织，因此每张表中可以有多个辅助索引。<br>当通过辅助索引来寻找数据时，InnoDB存储引擎会遍历辅助索引并通过叶子级别的指针获得主键索引的主键，然后通过主键索引找到一个完成的行记录。<br>假设辅助索引树高3层，聚集索引树为3层，那么根据辅助索引查找数据，需要先经过3次IO找到主键，再经过3次IO找到行做在的数据页，共6次</p>\n<h3 id=\"联合索引\"><a href=\"#联合索引\" class=\"headerlink\" title=\"联合索引\"></a>联合索引</h3><p>本质上说 联合索引内部也是一棵B+Tree ，不同的是联合索引的键值数量不是<code>1</code> 而是 <code>&gt;=2</code>.</p>\n<p>最左匹配原则</p>\n<h3 id=\"覆盖索引-Covering-index\"><a href=\"#覆盖索引-Covering-index\" class=\"headerlink\" title=\"覆盖索引 (Covering index)\"></a>覆盖索引 (Covering index)</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>即 通过辅助索引中就可以查询到记录，而不需要通过聚簇索引。<br>使用覆盖索引的好处是辅助索引不包含整行记录的所有信息，故其大小远小于聚簇索引，因此可以减少大量的IO操作</p></blockquote>\n<ul>\n<li>从辅助索引中直接获取记录</li>\n<li>对于统计操作，例如count(1)，有可能联合索引，右边也会匹配（优化器自己会做），因为count(1)操作不需要获取整行的详细数据，所以不需要去聚集索引的叶子节点去获取数据，直接在辅助索引树中就完成了操作</li>\n<li>select username from xxx where username&#x3D;’lisi’，如果username是辅助索引，那么整个查询在辅助索引树上就可以完成，因为辅助索引树上虽然没有保存完整的行，但是保存着&lt;username,lisi&gt;这个key-value对；如果select username, age from xxx where username&#x3D;’lisi’，那么就要走聚集索引了</li>\n</ul>\n<h2 id=\"Hash-算法\"><a href=\"#Hash-算法\" class=\"headerlink\" title=\"Hash 算法\"></a>Hash 算法</h2><p>Hash 算法是一种常见的算法，时间复杂度为 O(1), 每个数据库应用中都存在这种数据库结构。</p>\n<p>对于可能产生的 <code>Hash碰撞</code>， mysql 采用<code>链表</code>的方式解决。</p>\n<h2 id=\"全文检索\"><a href=\"#全文检索\" class=\"headerlink\" title=\"全文检索\"></a>全文检索</h2><p>由于 B+Tree 索引的特点， 可以通过索引字段的前缀(prefix)进行查找。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token comment\"># 如下语句 B+Tree 索引是支持的</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> blog <span class=\"token keyword\">WHERE</span> content <span class=\"token operator\">like</span> <span class=\"token string\">'xxx%'</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><code>MySQL5.6</code>版本开始支持 InnoDB引擎 的全文索引，语法层面上大多数兼容之前 MyISAM s的全文索引模式。所谓全文索引，是一种通过建立倒排索引，快速匹配文档的方式。</p></blockquote>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token comment\"># 创建全文索引</span>\n<span class=\"token keyword\">create</span> <span class=\"token keyword\">table</span> tb_name <span class=\"token punctuation\">(</span>a <span class=\"token keyword\">int</span> <span class=\"token keyword\">auto_increment</span> <span class=\"token keyword\">primary</span> <span class=\"token keyword\">key</span><span class=\"token punctuation\">,</span> b <span class=\"token keyword\">text</span><span class=\"token punctuation\">,</span> fulltext<span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>详细了解: <a href=\"http://mysql.taobao.org/monthly/2015/10/01/\">InnoDB 全文索引简介</a></p>\n<h3 id=\"倒排索引\"><a href=\"#倒排索引\" class=\"headerlink\" title=\"倒排索引\"></a>倒排索引</h3><p>全文检索通常使用倒排索引(inverted index)实现。倒排索引同 B+Tree 索引一样，也是一种索引结构。他在辅助表中存储了单词与单词自身在一个或者多个文档中所在位置之间的映射。这种关联关系通过关联那数组实现。</p>\n","text":"索引 在系统中，为了提高查询性能，这里 主要记录 InnoDB存储引擎的索引，InnoDB 支持一下几种常见的索引 B+Tree索引 全文索引 Hash索引 为什么要有索引？索引在MySQL中也叫做 键，是存储引擎用于快速找到记录的一种数据结构。索引对于良好的性能非常关键，尤其是...","link":"","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[{"name":"mysql","slug":"mysql","count":3,"path":"api/categories/mysql.json"}],"tags":[{"name":"mysql","slug":"mysql","count":3,"path":"api/tags/mysql.json"},{"name":"索引","slug":"索引","count":1,"path":"api/tags/索引.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">索引</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E7%B4%A2%E5%BC%95%EF%BC%9F\"><span class=\"toc-text\">为什么要有索引？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">索引的数据结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#B-Tree%E7%9A%84%E6%9F%A5%E6%89%BE%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">B+Tree的查找过程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#B-Tree-%E6%80%A7%E8%B4%A8\"><span class=\"toc-text\">B+Tree 性质</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B4%A2%E5%BC%95%E7%9A%84%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">索引的类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#B-Tree-%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">B+Tree 索引</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">聚簇索引</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">辅助索引</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">联合索引</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95-Covering-index\"><span class=\"toc-text\">覆盖索引 (Covering index)</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Hash-%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">Hash 算法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2\"><span class=\"toc-text\">全文检索</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">倒排索引</span></a></li></ol></li></ol>","author":{"name":"majm","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"技术分享","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Mysql锁概念","uid":"d876370ed0a462e054a9f9f7d4c5e0de","slug":"Mysql锁概念","date":"2019-06-13T12:31:15.000Z","updated":"2022-03-03T15:50:36.095Z","comments":true,"path":"api/articles/Mysql锁概念.json","keywords":null,"cover":[],"text":"INNODB 存储引擎中的锁 类型InnoDB 实现了如下两种类型的行锁： 共享锁(S Lock)允许事务读取一行数据 排它锁(X Lock)允许事务更新或者删除一行数据 锁的兼容性如果一个事务请求的锁模式与当前的锁兼容， InnoDB 就将请求的锁授予该事务: 反之, 如果两者...","link":"","photos":[],"count_time":{"symbolsCount":"3.5k","symbolsTime":"3 mins."},"categories":[{"name":"mysql","slug":"mysql","count":3,"path":"api/categories/mysql.json"},{"name":"锁","slug":"mysql/锁","count":1,"path":"api/categories/mysql/锁.json"}],"tags":[{"name":"mysql","slug":"mysql","count":3,"path":"api/tags/mysql.json"},{"name":"锁","slug":"锁","count":1,"path":"api/tags/锁.json"}],"author":{"name":"majm","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"技术分享","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Tomcat源码导入-IntelijIdea","uid":"2702307c6aa4465d038db73bd559dfd1","slug":"Tomcat源码导入-IntelijIdea","date":"2019-06-06T06:18:45.000Z","updated":"2022-03-03T15:51:26.720Z","comments":true,"path":"api/articles/Tomcat源码导入-IntelijIdea.json","keywords":null,"cover":[],"text":" 最近有兴趣阅读一下 Tomcat 源码 先把准备工作做一下， 有时间在深入阅读。 嘻嘻maven tomcat idea 官网下载 Tomcat 源码包官网 我这里用到的 tomcat 版本是 8.5.41. 项目结构 新建一个 目录 tomcat8.5-src将源码包解压到该...","link":"","photos":[],"count_time":{"symbolsCount":"5.3k","symbolsTime":"5 mins."},"categories":[{"name":"tomcat","slug":"tomcat","count":1,"path":"api/categories/tomcat.json"}],"tags":[{"name":"maven","slug":"maven","count":2,"path":"api/tags/maven.json"},{"name":"tomcat","slug":"tomcat","count":1,"path":"api/tags/tomcat.json"},{"name":"idea","slug":"idea","count":1,"path":"api/tags/idea.json"}],"author":{"name":"majm","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"技术分享","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}