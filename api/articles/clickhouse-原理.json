{"title":"clickhouse-原理","uid":"7f644a5a0ef8dce45a5c7a8966cb4d95","slug":"clickhouse-原理","date":"2022-08-11T17:00:53.000Z","updated":"2022-09-08T05:05:51.621Z","comments":true,"path":"api/articles/clickhouse-原理.json","keywords":null,"cover":[],"content":"<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Clickhouse 是一个 用于联机分析(OLAP)的 列式存储数据库管理系统(DBMS).</p></blockquote>\n<span id=\"more\"></span>\n\n<p>常见的列式数据库有: Vertica、 Paraccel (Actian Matrix，<code>Amazon Redshift</code>)、 Sybase IQ、 Exasol、 Infobright、 InfiniDB、 MonetDB (VectorWise， Actian Vector)、 LucidDB、 SAP HANA、 Google Dremel、 Google PowerDrill、 <code>Druid</code>、 kdb+.</p>\n<h2 id=\"OLAP-场景的关键特征\"><a href=\"#OLAP-场景的关键特征\" class=\"headerlink\" title=\"OLAP 场景的关键特征\"></a>OLAP 场景的关键特征</h2><ul>\n<li>绝大多数是读请求</li>\n<li>数据以相当大的批次(&gt; 1000行)更新，而不是单行更新;或者根本没有更新。</li>\n<li>已添加到数据库的数据不能修改。</li>\n<li>对于读取，从数据库中提取相当多的行，但只提取列的一小部分。</li>\n<li>宽表，即每个表包含着大量的列</li>\n<li>查询相对较少(通常每台服务器每秒查询数百次或更少)</li>\n<li>对于简单查询，允许延迟大约50毫秒</li>\n<li>列中的数据相对较小：数字和短字符串(例如，每个URL 60个字节)</li>\n<li>处理单个查询时需要高吞吐量(每台服务器每秒可达数十亿行)</li>\n<li>事务不是必须的</li>\n<li>对数据一致性要求低</li>\n<li>每个查询有一个大表。除了他以外，其他的都很小。</li>\n<li>查询结果明显小于源数据。换句话说，数据经过过滤或聚合，因此结果适合于单个服务器的RAM中</li>\n</ul>\n<h2 id=\"列式数据库更适合OLAP场景的原因\"><a href=\"#列式数据库更适合OLAP场景的原因\" class=\"headerlink\" title=\"列式数据库更适合OLAP场景的原因\"></a>列式数据库更适合OLAP场景的原因</h2><p>列式数据库更适合于OLAP场景(对于大多数查询而言，处理速度至少提高了100倍).</p>\n<p><img src=\"https://clickhouse.com/docs/assets/images/row-oriented-d515facb5bffb48cbd09dc7d064c8816.gif#\"></p>\n<p><img src=\"https://clickhouse.com/docs/assets/images/column-oriented-b992c529fa4085b63b57452fbbeb27ba.gif#\"></p>\n<p>为什么会出现这种情况?</p>\n<h3 id=\"1-IO\"><a href=\"#1-IO\" class=\"headerlink\" title=\"1. IO\"></a>1. IO</h3><ul>\n<li>针对分析类查询, 通常只需要读取表的一小部分列.在列式数据库中你可以只读取你需要的数据.例如，如果只需要读取100列中的5列，这将帮助你最少减少20倍的I&#x2F;O消耗.</li>\n<li>由于数据总是打包成批量读取的，所以压缩是非常容易的.同时数据按列分别存储这也更容易压缩.这进一步降低了I&#x2F;O的体积.</li>\n<li>由于I&#x2F;O的降低,这将帮助更多的数据被系统缓存.</li>\n<li>例如: 查询<code>统计每个广告平台的记录数量</code>需要读取<code>广告平台ID</code>这一列,它在未压缩的情况下需要1个字节进行存储.如果大部分流量不是来自广告平台，那么这一列至少可以以十倍的压缩率被压缩.当采用快速压缩算法,它的解压速度最少在十亿字节(未压缩数据)每秒.换句话说,这个查询可以在单个服务器上以每秒大约几十亿行的速度进行处理.这实际上是当前实现的速度。</li>\n</ul>\n<h3 id=\"2-CPU\"><a href=\"#2-CPU\" class=\"headerlink\" title=\"2.  CPU\"></a>2.  CPU</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>由于执行一个查询需要处理大量的行,因此在整个向量上执行所有操作将比在每一行上执行所有操作更加高效.<br>同时这将有助于实现一个几乎没有调用成本的查询引擎.如果你不这样做,使用任何一个机械硬盘.查询引擎都不可避免的停止CPU进行等待.<br>所以,在数据按列存储并且按列执行是很有意义的.</p></blockquote>\n<p>有两种方法可以做到这一点: </p>\n<ul>\n<li><p>向量引擎: 所有的操作都是为向量而不是为单个值编写的.这意味着多个操作之间的不再需要频繁的调用,并且调用的成本基本可以忽略不计.操作代码包含一个优化的内部循环.</p>\n</li>\n<li><p>代码生成: 生成一段代码,包含查询中的所有操作.</p>\n</li>\n</ul>\n<hr>\n<p>[参考]<br><a href=\"https://clickhouse.com/docs/zh/\">什么是clickhouse</a></p>\n","text":" Clickhouse 是一个 用于联机分析(OLAP)的 列式存储数据库管理系统(DBMS). 常见的列式数据库有: Vertica、 Paraccel (Actian Matrix，Amazon Redshift)、 Sybase IQ、 Exasol、 Infobright...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"clickhouse","slug":"clickhouse","count":1,"path":"api/tags/clickhouse.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#OLAP-%E5%9C%BA%E6%99%AF%E7%9A%84%E5%85%B3%E9%94%AE%E7%89%B9%E5%BE%81\"><span class=\"toc-text\">OLAP 场景的关键特征</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%97%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9B%B4%E9%80%82%E5%90%88OLAP%E5%9C%BA%E6%99%AF%E7%9A%84%E5%8E%9F%E5%9B%A0\"><span class=\"toc-text\">列式数据库更适合OLAP场景的原因</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-IO\"><span class=\"toc-text\">1. IO</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-CPU\"><span class=\"toc-text\">2.  CPU</span></a></li></ol></li></ol>","author":{"name":"majm","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"技术分享","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"golang-sync.Pool解析","uid":"bc5ccb2e868ae0ec4cf759c000e9d341","slug":"golang-sync-Pool解析","date":"2022-08-11T17:15:26.000Z","updated":"2022-08-15T16:11:27.997Z","comments":true,"path":"api/articles/golang-sync-Pool解析.json","keywords":null,"cover":[],"text":"sync.Pool是sync包下的一个组件,可以作为临时取还对象的一个 池子. 作用: 对于很多需要重复分配、回收内存的地方,sync.Pool 是一个很好的选择.频繁地分配、回收内存会给 GC 带来一定的负担,严重的时候会引起 CPU 的毛刺,而 sync.Pool 可以将暂时...","link":"","photos":[],"count_time":{"symbolsCount":"18k","symbolsTime":"16 mins."},"categories":[],"tags":[{"name":"golang","slug":"golang","count":9,"path":"api/tags/golang.json"}],"author":{"name":"majm","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"技术分享","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"go build 实现包切换","uid":"d96ad83bba94948fc2ba2a5f3d6fbcb0","slug":"go-build-实现包切换","date":"2022-08-03T04:18:02.000Z","updated":"2022-09-03T07:45:16.171Z","comments":true,"path":"api/articles/go-build-实现包切换.json","keywords":null,"cover":null,"text":"参考 Gin 的实现 gin 在 internal/json包中实现了多个 json 包的序列化能力, 默认使用官方encoding/json包. 如何保证这些包不会冲突呢? 这里用到了 go build -tags 的能力. [json.go](https://github.c...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"go","slug":"go","count":2,"path":"api/tags/go.json"},{"name":"go build","slug":"go-build","count":1,"path":"api/tags/go-build.json"}],"author":{"name":"majm","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"技术分享","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}