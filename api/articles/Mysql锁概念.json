{"title":"Mysql锁概念","uid":"d876370ed0a462e054a9f9f7d4c5e0de","slug":"Mysql锁概念","date":"2019-06-13T12:31:15.000Z","updated":"2022-03-03T15:50:36.095Z","comments":true,"path":"api/articles/Mysql锁概念.json","keywords":null,"cover":[],"content":"<h2 id=\"INNODB-存储引擎中的锁\"><a href=\"#INNODB-存储引擎中的锁\" class=\"headerlink\" title=\"INNODB 存储引擎中的锁\"></a>INNODB 存储引擎中的锁</h2><span id=\"more\"></span>\n\n<h3 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h3><p>InnoDB 实现了如下两种类型的行锁：</p>\n<ul>\n<li><p>共享锁(S Lock)<br>允许事务读取一行数据</p>\n</li>\n<li><p>排它锁(X Lock)<br>允许事务更新或者删除一行数据</p>\n</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>锁的兼容性<br>如果一个事务请求的锁模式与当前的锁兼容， InnoDB 就将请求的锁授予该事务: 反之, 如果两者不兼容,该事务就要等待锁释放.</p></blockquote>\n<p><strong>排它锁和共享锁的兼容性</strong></p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>X</th>\n<th>S</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>X</td>\n<td>不兼容</td>\n<td>不兼容</td>\n</tr>\n<tr>\n<td>S</td>\n<td>不兼容</td>\n<td>兼容</td>\n</tr>\n</tbody></table>\n<p>X S 锁都是行锁，兼容指的是对同一条记录(row)锁的兼容性</p>\n<p>此外，<code>InnoDB存储引擎</code>还支持<code>多粒度(granular)锁定</code>，这种锁定允许事务在 行级上的锁 和 表级上的锁 同时锁定。<br>为了支持在不同粒度上的进行加锁操作，<code>InnoDB存储引擎</code>支持一种额外的加锁方式 <code>意向锁(Intention Lock)</code>.<br><code>意向锁</code>将锁定的对象分为多个层次，<code>意向锁</code>意味着事务希望在更细粒度上进行加锁。</p>\n<ul>\n<li>意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。</li>\n<li>意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。</li>\n</ul>\n<p><strong>表级意向锁和行级意向锁的兼容性</strong></p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>IS</th>\n<th>IX</th>\n<th>S</th>\n<th>X</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>IS</td>\n<td>兼容</td>\n<td>兼容</td>\n<td>兼容</td>\n<td>不兼容</td>\n</tr>\n<tr>\n<td>IX</td>\n<td>兼容</td>\n<td>兼容</td>\n<td>不兼容</td>\n<td>不兼容</td>\n</tr>\n<tr>\n<td>S</td>\n<td>兼容</td>\n<td>不兼容</td>\n<td>兼容</td>\n<td>不兼容</td>\n</tr>\n<tr>\n<td>X</td>\n<td>不兼容</td>\n<td>不兼容</td>\n<td>不兼容</td>\n<td>不兼容</td>\n</tr>\n</tbody></table>\n<h3 id=\"InnoDB-加锁方式\"><a href=\"#InnoDB-加锁方式\" class=\"headerlink\" title=\"InnoDB 加锁方式\"></a>InnoDB 加锁方式</h3><ul>\n<li>意向锁是 InnoDB 自动加的， 不需用户干预。</li>\n<li>对于 UPDATE、 DELETE 和 INSERT 语句， InnoDB<br>会自动给涉及数据集加排他锁（X)；</li>\n<li>对于普通 SELECT 语句，InnoDB 不会加任何锁；<br>事务可以通过以下语句显式给记录集加共享锁或排他锁：<ul>\n<li>共享锁（S）：SELECT * FROM table_name WHERE … LOCK IN SHARE MODE。 其他 session 仍然可以查询记录，并也可以对该记录加 share mode 的共享锁。但是如果当前事务需要对该记录进行更新操作，则很有可能造成死锁。</li>\n<li>排他锁（X)：SELECT * FROM table_name WHERE … FOR UPDATE。其他 session 可以查询该记录，但是不能对该记录加共享锁或排他锁，而是等待获得锁</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"一致性非锁定读\"><a href=\"#一致性非锁定读\" class=\"headerlink\" title=\"一致性非锁定读\"></a>一致性非锁定读</h3><p>一致性非锁定读是InnoDB存储引擎通过<code>多版本控制（multi versioning</code> 的方式来读取当前执行时间数据库中的数据。如果被读的数据行被加了<code>排他锁</code>，在读取这行数据的时候并不会等待锁释放，而是读取该行的一个<code>快照数据</code>。 之所以称为非锁定读，因为不需要等待被访问行的<code>X锁</code>的释放。<code>快照数据</code>是指修改行之前的数据版本，该实现通过<code>undo段</code>来完成。<code>非锁定读</code>的方式极大提高了数据库的并发性。<strong>在InnoDB存储引擎中，这是默认的读取方式。</strong></p>\n<p><code>快照数据</code>其实就是当前行数据的一个历史版本，每行记录可能有多个版本。这种技术成为行多版本技术。由此带来的并发控制，称为<code>多版本并发控制(MVCC)</code></p>\n<p>在事务的隔离级别 <code>READ COMMITED</code>和<code>REPEATABLE READ</code> *(InnoDB存储引擎默认的事物隔离级别)*下，对<code>快照数据</code>的定义不同。</p>\n<ul>\n<li>在<code>READ COMMITTED</code>事务隔离级别下<br>同一事务内的一致性读均会读取到该事务中第一个读创建的快照，其他事务在之后<code>提交或未提交的更新</code>对当前事务的读均不可见，除非提交了该事务并开启新事务发起新查询。</li>\n<li>在<code>REPEATABLE READ</code>事务隔离级别下<br>事务内的每个一致性读均会设置和读取自己新鲜的快照。其他事务在之后<code>提交的更新</code>对当前事务的读可见，<code>未提交的更新</code>对当前事务不可见。</li>\n</ul>\n<p>一致性读 是 InnoDB引擎 处理 <code>READ COMMIT</code> 和 <code>REPEATABLE READ</code> 隔离级别中 <code>SELECT</code> 的默认方式，不需要对 <code>SELECT</code> 访问的对象加锁，其他 session 中的事务可以在另一 session 中的事务读去的同时自由的修改相关对象，因此称为<code>非锁定一致性读</code>。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token comment\"># 查看当前数据库的 事务隔离级别</span>\n<span class=\"token keyword\">SELECT</span> @<span class=\"token variable\">@tx_isolation</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p><img src=\"/post/Mysql%E9%94%81%E6%A6%82%E5%BF%B5/%E9%9D%9E%E9%94%81%E5%AE%9A%E4%B8%80%E8%87%B4%E6%80%A7%E8%AF%BB%E7%9A%84%E9%97%AE%E9%A2%98.jpg\" alt=\"非锁定一致性读的问题\"></p>\n<p>起初事务的隔离级别均为<code>REPEATABLE-READ</code>。SESSION 读取的内容为i&#x3D;1,2,3的行，在 SESSION B 中的事务更新了 i&#x3D;3 的行后 SESSION A 查询到的内容并没有改变，即时在 SESSION B 提交了该更新后 SESSION A 仍只能看到最开始的一致性读创建的快照。但是，在 SESSION A 中的事务执行<code>UPDATE语句</code>更新了被 SESSION B 更新的记录后（数据库快照只适用于<code>SELECT</code>语句，不适用与<code>DML语句</code>，所以事务中的<code>DML语句</code>是可以看到 其他session 中的事务的更新的，即使<code>SELECT</code>并不能看到这些）再次执行<code>SELECT语句</code>不仅可以看到快照中的数据，还可以看到更新后的数据。</p>\n<p>上述提到的一致性读由多版本并发控制（MVCC）原理实现（利用了InnoDB的undo log）。需要注意的是，一致性读不适用于特定的DDL语句如DROP TABLE、ALTER TABLE。另外，对于 INSERT INTO … SELECT, UPDATE … (SELECT)和CREATE TABLE … SELECT 中未指定FOR UPDATE或LOCK IN SHARE MODE的SELECT默认情况下行为和READ COMMIT隔离级别下的普通SELECT一样，同一事务内设置和读取自己的新鲜快照。</p>\n<h3 id=\"一致性锁定读\"><a href=\"#一致性锁定读\" class=\"headerlink\" title=\"一致性锁定读\"></a>一致性锁定读</h3><p><code>锁定读</code>。顾名思义，非锁定一致性读在某个事务读取记录时不加任何锁其他事务可以修改记录，而锁定读意味着某个事务读取记录时会加锁。锁定读分为两种类型：<code>SELECT...FOR UPDATE</code> 和 <code>SELECT...LOCK IN SHARE MODE</code>，前者会对读取的记录加<code>X锁</code>，阻塞其他事务的读请求和修改请求，直至事务提交释放锁资源；后者会对读取的记录加<code>S锁</code>，阻塞其他事务的修改请求但不会阻塞读取请求，直至事务提交释放锁资源。也正因为<code>SELECT...FOR UPDATE</code> 和 <code>SELECT...LOCK IN SHARE MODE</code> 分别需要对查询的记录加<code>X锁</code>和<code>S锁</code>，因此分别会被其他正在读写和写的事务阻塞，直到这些事务结束。需要注意的是<code>SELECT...FOR UPDATE</code>仅适用于<code>autocommit=0</code> 或者通过<code>START TRANSACTION</code>明确开启事务的情况。</p>\n<p>因为锁定读会阻塞其他事务的修改请求，因此可以有效解决<code>非锁定一致性读</code>中提到的”异常”，也即，一个事务执行了普通<code>SELECT</code>后若其他的事务更新、插入了记录并提交，那么该事务内执行<code>DML操作</code>更新被其他事务更新或插入的记录后再次执行<code>SELECT</code>操作会看到更新后的结果。(非锁定一致性读的示例)</p>\n<h4 id=\"锁定读的一个典型应用常场景\"><a href=\"#锁定读的一个典型应用常场景\" class=\"headerlink\" title=\"锁定读的一个典型应用常场景\"></a>锁定读的一个典型应用常场景</h4><p>(先查询, 后更新 的操作)</p>\n<p>假如要往子表插入一条记录，插入前首先要确认一下父表有无相关记录，只有在父表有对应记录时插入才能满足引用完整性约束。如果使用<code>一致性读</code>来查询父表来验证相关行存在，此时往子表插入时 其他的session 有可能更新或者删除刚才父表中查到的行，这样在子表中插入后就违反了引用完整性约束。为了避免该问题可使用<code>锁定读SELECT...LOCK IN SHARE MODE</code>，在事务中读取父表进行验证时，对相关记录加S锁，这样其他事务无法对相关记录进行<code>DML操作</code>，此时可在事务中安全的插入相关记录，待此操作完成并提交或回滚后其他事务才能对记录进行<code>DML操作</code>。</p>\n<p>还有一种情况，比如有 两个session 需要读取某表中的一行，在成功读取后在同一事务中更新该行，并在另外的表中插入刚开始读取到的行。若此时使用<code>SELECT...LOCK IN SHARE MODE</code>则会对读取到的记录加<code>S锁</code>，两个session在同时申请<code>X锁</code>进行更新时便发生死锁。另外，由于读取到了同一行内容，两个session在向同一表插入数据时会导致键重复的错误。这种情况下用SELECT…FOR UPDATE较合适，在读取的时候阻塞其他事物的读和更新请求。</p>\n<p><img src=\"/post/Mysql%E9%94%81%E6%A6%82%E5%BF%B5/SELECT_FOR_UPDATE.jpg\" alt=\"SELECT_FOR_UPDATE\"></p>\n<hr>\n<p>[参考]<br><a href=\"https://blog.csdn.net/zyz511919766/article/details/49451255\">（三）MySQL InnoDB非锁定一致性读与锁定读</a><br><a href=\"https://blog.csdn.net/paopaopotter/article/details/79259686\">数据库第一类第二类丢失更新</a></p>\n","text":"INNODB 存储引擎中的锁 类型InnoDB 实现了如下两种类型的行锁： 共享锁(S Lock)允许事务读取一行数据 排它锁(X Lock)允许事务更新或者删除一行数据 锁的兼容性如果一个事务请求的锁模式与当前的锁兼容， InnoDB 就将请求的锁授予该事务: 反之, 如果两者...","link":"","photos":[],"count_time":{"symbolsCount":"3.5k","symbolsTime":"3 mins."},"categories":[{"name":"mysql","slug":"mysql","count":3,"path":"api/categories/mysql.json"},{"name":"锁","slug":"mysql/锁","count":1,"path":"api/categories/mysql/锁.json"}],"tags":[{"name":"mysql","slug":"mysql","count":3,"path":"api/tags/mysql.json"},{"name":"锁","slug":"锁","count":1,"path":"api/tags/锁.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#INNODB-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E9%94%81\"><span class=\"toc-text\">INNODB 存储引擎中的锁</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#InnoDB-%E5%8A%A0%E9%94%81%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">InnoDB 加锁方式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E8%87%B4%E6%80%A7%E9%9D%9E%E9%94%81%E5%AE%9A%E8%AF%BB\"><span class=\"toc-text\">一致性非锁定读</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E8%87%B4%E6%80%A7%E9%94%81%E5%AE%9A%E8%AF%BB\"><span class=\"toc-text\">一致性锁定读</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%94%81%E5%AE%9A%E8%AF%BB%E7%9A%84%E4%B8%80%E4%B8%AA%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%B8%B8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">锁定读的一个典型应用常场景</span></a></li></ol></li></ol></li></ol>","author":{"name":"majm","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"技术分享","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"自己写一个spring-boot-start","uid":"802c655d6d6544d494d9d5e09a52a6ba","slug":"自己写一个spring-boot-start","date":"2019-07-04T11:33:13.000Z","updated":"2022-03-03T15:49:41.563Z","comments":true,"path":"api/articles/自己写一个spring-boot-start.json","keywords":null,"cover":[],"text":" Spring Boot由众多Starter组成，随着版本的推移Starter家族成员也与日俱增。在传统Maven项目中通常将一些层、组件拆分为模块来管理， 以便相互依赖复用，在Spring Boot项目中我们则可以创建自定义Spring Boot Starter来达成该目的。 ...","link":"","photos":[],"count_time":{"symbolsCount":"4.5k","symbolsTime":"4 mins."},"categories":[{"name":"spring","slug":"spring","count":3,"path":"api/categories/spring.json"}],"tags":[{"name":"spring","slug":"spring","count":3,"path":"api/tags/spring.json"},{"name":"springboot","slug":"springboot","count":1,"path":"api/tags/springboot.json"}],"author":{"name":"majm","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"技术分享","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Mysql索引原理","uid":"ce52f41a783fc1c1eec924862c197938","slug":"Mysql索引原理","date":"2019-06-12T14:18:19.000Z","updated":"2022-03-03T15:51:13.983Z","comments":true,"path":"api/articles/Mysql索引原理.json","keywords":null,"cover":[],"text":"索引 在系统中，为了提高查询性能，这里 主要记录 InnoDB存储引擎的索引，InnoDB 支持一下几种常见的索引 B+Tree索引 全文索引 Hash索引 为什么要有索引？索引在MySQL中也叫做 键，是存储引擎用于快速找到记录的一种数据结构。索引对于良好的性能非常关键，尤其是...","link":"","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[{"name":"mysql","slug":"mysql","count":3,"path":"api/categories/mysql.json"}],"tags":[{"name":"mysql","slug":"mysql","count":3,"path":"api/tags/mysql.json"},{"name":"索引","slug":"索引","count":1,"path":"api/tags/索引.json"}],"author":{"name":"majm","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"技术分享","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}