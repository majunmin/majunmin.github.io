{"title":"mysql查询计划查看","uid":"d50659b13cff259d9728e80e6b8aee70","slug":"mysql查询计划查看","date":"2019-06-05T08:24:52.000Z","updated":"2022-03-03T15:50:13.675Z","comments":true,"path":"api/articles/mysql查询计划查看.json","keywords":null,"cover":[],"content":"<p>MySql提供了EXPLAIN语法用来进行查询分析，在SQL语句前加一个”EXPLAIN”即可。比如我们要分析如下SQL语句：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">explain</span> <span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> <span class=\"token keyword\">table</span> <span class=\"token keyword\">where</span> <span class=\"token keyword\">table</span><span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<span id=\"more\"></span>\n\n<p>运行上面的sql语句后你会看到，下面的表头信息：<br><img src=\"/post/mysql%E6%9F%A5%E8%AF%A2%E8%AE%A1%E5%88%92%E6%9F%A5%E7%9C%8B/mysql%E6%9F%A5%E8%AF%A2%E8%AE%A1%E5%88%92.jpg\" alt=\"mysql查询计划\"></p>\n<ul>\n<li><p><code>id</code><br>Query Optimizer 所选定的执行计划中查询的序列号。</p>\n</li>\n<li><p><code>select_type</code><br>所使用的查询类型，主要有以下这几种查询类型</p>\n<ul>\n<li><code>DEPENDENT SUBQUERY</code>：子查询中内层的第一个SELECT，依赖于外部查询的结果集。</li>\n<li><code>DEPENDENT UNION</code>：子查询中的UNION，且为UNION 中从第二个SELECT 开始的后面所有SELECT，同样依赖于外部查询的结果集。</li>\n<li><code>PRIMARY</code>：子查询中的最外层查询，注意并不是主键查询。</li>\n<li><code>SIMPLE</code>：除子查询或者UNION 之外的其他查询。</li>\n<li><code>SUBQUERY</code>：子查询内层查询的第一个SELECT，结果不依赖于外部查询结果集。</li>\n<li><code>UNCACHEABLE SUBQUERY</code>：结果集无法缓存的子查询。</li>\n<li><code>UNION</code>：UNION 语句中第二个SELECT 开始的后面所有SELECT，第一个SELECT 为PRIMARY</li>\n<li><code>UNION RESULT</code>：UNION 中的合并结果。</li>\n</ul>\n</li>\n<li><p><code>table</code> 表名</p>\n</li>\n<li><p><code>type</code> 告诉我们对表所使用的访问方式，<br>all 全表扫描<br>index：全索引扫描。<br>range：索引范围扫描。<br>ref：Join 语句中被驱动表索引引用查询。</p>\n<p>从最好到最差的连接类型为<br>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p></blockquote>\n<p><em>一般来说，好的sql查询至少达到<code>range</code>级别，最好能达到<code>ref</code></em></p>\n</li>\n<li><p><code>possible_keys</code>  显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从WHERE语句中选择一个合适的语句</p>\n</li>\n<li><p><code>key</code> 实际使用的索引。如果为NULL，则没有使用索引。很少的情况下，MYSQL会选择优化不足的索引。这种情况下，可以在SELECT语句中使用USE INDEX（indexname）来强制使用一个索引或者用IGNORE INDEX（indexname）来强制MYSQL忽略索引</p>\n</li>\n<li><p><code>key_len</code>  使用的索引的长度。在不损失精确性的情况下，长度越短越好</p>\n</li>\n<li><p><code>ref</code>  显示索引的哪一列被使用了，如果可能的话，是一个常数</p>\n</li>\n<li><p><code>rows</code>  MYSQL认为必须检查的用来返回请求数据的行数</p>\n</li>\n<li><p><code>Extra</code> 关于MYSQL如何解析查询的额外信息。 可能取值如下</p>\n<ul>\n<li>Distinct：查找distinct 值，所以当mysql 找到了第一条匹配的结果后，将停止该值的查询而转为后面其他值的查询。</li>\n<li>Full scan on NULL key：子查询中的一种优化方式，主要在遇到无法通过索引访问null值的使用使用。</li>\n<li>Impossible WHERE noticed after reading const tables：MySQL Query Optimizer 通过收集到的统计信息判断出不可能存在结果。</li>\n<li>No tables：Query 语句中使用FROM DUAL 或者不包含任何FROM 子句。</li>\n<li>Not exists：在某些左连接中MySQL Query Optimizer 所通过改变原有Query 的组成而使用的优化方法，可以部分减少数据访问次数。</li>\n<li>Range checked for each record (index map: N)：通过MySQL 官方手册的描述，当MySQL Query Optimizer 没有发现好的可以使用的索引的时候，如果发现如果来自前面的表的列值已知，可能部分索引可以使用。对前面的表的每个行组合，MySQL 检查是否可以使用range 或index_merge 访问方法来索取行。</li>\n<li>Select tables optimized away：当我们使用某些聚合函数来访问存在索引的某个字段的时候，MySQL Query Optimizer 会通过索引而直接一次定位到所需的数据行完成整个查询。当然，前提是在Query 中不能有GROUP BY 操作。如使用MIN()或者MAX（）的时候。</li>\n<li>Using filesort：当我们的Query 中包含ORDER BY 操作，而且无法利用索引完成排序操作的时候，MySQL Query Optimizer 不得不选择相应的排序算法来实现。</li>\n<li><code>Using index</code>：所需要的数据只需要在Index 即可全部获得而不需要再到表中取数据。</li>\n<li><code>Using index for group-by</code>：数据访问和Using index 一样，所需数据只需要读取索引即可，而当Query 中使用了GROUP BY 或者DISTINCT 子句的时候，如果分组字段也在索引中，Extra 中的信息就会是Using index for group-by。</li>\n<li><code>Using temporary</code>：当MySQL 在某些操作中必须使用临时表的时候，在Extra 信息中就会出现Using temporary 。主要常见于GROUP BY 和ORDER BY 等操作中。</li>\n<li><code>Using where</code>：如果我们不是读取表的所有数据，或者不是仅仅通过索引就可以获取所有需要的数据，则会出现Using where 信息。</li>\n<li>Using where with pushed condition：这是一个仅仅在NDBCluster 存储引擎中才会出现的信息，而且还需要通过打开Condition Pushdown 优化功能才可能会被使用。控制参数为engine_condition_pushdown 。</li>\n</ul>\n</li>\n</ul>\n","text":"MySql提供了EXPLAIN语法用来进行查询分析，在SQL语句前加一个”EXPLAIN”即可。比如我们要分析如下SQL语句： explain select * from table where table.id = 1 运行上面的sql语句后你会看到，下面的表头信息： idQu...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"mysql","slug":"mysql","count":3,"path":"api/categories/mysql.json"}],"tags":[{"name":"mysql","slug":"mysql","count":3,"path":"api/tags/mysql.json"},{"name":"查询计划","slug":"查询计划","count":1,"path":"api/tags/查询计划.json"}],"toc":"","author":{"name":"majm","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"技术分享","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Tomcat源码导入-IntelijIdea","uid":"2702307c6aa4465d038db73bd559dfd1","slug":"Tomcat源码导入-IntelijIdea","date":"2019-06-06T06:18:45.000Z","updated":"2022-03-03T15:51:26.720Z","comments":true,"path":"api/articles/Tomcat源码导入-IntelijIdea.json","keywords":null,"cover":[],"text":" 最近有兴趣阅读一下 Tomcat 源码 先把准备工作做一下， 有时间在深入阅读。 嘻嘻maven tomcat idea 官网下载 Tomcat 源码包官网 我这里用到的 tomcat 版本是 8.5.41. 项目结构 新建一个 目录 tomcat8.5-src将源码包解压到该...","link":"","photos":[],"count_time":{"symbolsCount":"5.3k","symbolsTime":"5 mins."},"categories":[{"name":"tomcat","slug":"tomcat","count":1,"path":"api/categories/tomcat.json"}],"tags":[{"name":"maven","slug":"maven","count":2,"path":"api/tags/maven.json"},{"name":"tomcat","slug":"tomcat","count":1,"path":"api/tags/tomcat.json"},{"name":"idea","slug":"idea","count":1,"path":"api/tags/idea.json"}],"author":{"name":"majm","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"技术分享","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Spring-AOP详解","uid":"bfa33a5fe2e0aa639906339c30ac4485","slug":"Spring-AOP详解","date":"2019-06-04T06:51:48.000Z","updated":"2022-03-03T15:50:52.810Z","comments":true,"path":"api/articles/Spring-AOP详解.json","keywords":null,"cover":[],"text":"springDOC 将重复性的逻辑代码横切出来其实很容易(我们简单可认为就是封装成一个类就好了)，但我们要将这些被我们横切出来的逻辑代码融合到业务逻辑中，来完成和之前(没抽取前)一样的功能！这就是AOP首要解决的问题了！这样一来，我们就在写业务时只关心业务代码，而不用关心与业务无...","link":"","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[{"name":"spring","slug":"spring","count":3,"path":"api/categories/spring.json"}],"tags":[{"name":"spring","slug":"spring","count":3,"path":"api/tags/spring.json"},{"name":"aop","slug":"aop","count":1,"path":"api/tags/aop.json"},{"name":"动态代理","slug":"动态代理","count":1,"path":"api/tags/动态代理.json"}],"author":{"name":"majm","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"技术分享","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}