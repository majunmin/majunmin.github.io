{"title":"Kafka 入门","uid":"937bc65e7fc0650a79730217f9c7b325","slug":"Kafka-入门","date":"2019-04-28T07:08:15.000Z","updated":"2022-03-03T15:51:22.323Z","comments":true,"path":"api/articles/Kafka-入门.json","keywords":null,"cover":[],"content":"<p><a href=\"https://kafka.apache.org/\">英文文档</a> <em>|</em> <a href=\"http://kafka.apachecn.org/\">中文文档</a></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Kafka 是由 LinkedIn 开发的一个分布式的消息系统，使用 Scala 编写，它以可水平扩展和高吞吐率而被广泛使用。</p></blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"Mac-安装kafka\"><a href=\"#Mac-安装kafka\" class=\"headerlink\" title=\"Mac 安装kafka\"></a>Mac 安装kafka</h2><pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\"># 会自动 安装会依赖zookeeper\nbrew install kafka\n\n# 启动 zookeeper\nzookeeper-server-start &#x2F;usr&#x2F;local&#x2F;etc&#x2F;kafka&#x2F;zookeeper.properties &amp;\n\n# 启动 kafka\nkafka-server-start &#x2F;usr&#x2F;local&#x2F;etc&#x2F;kafka&#x2F;server.properties &amp;\n\n#创建 topic\nkafka-topics --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test\n\n# 查看创建的topic\nkafka-topics --list --zookeeper localhost:2181\n\n# 发送消息 输入\nkafka-console-producer --broker-list localhost:9092 --topic test\n# 在命令行输入消息并回车即可发送消息。\n# 默认每一行都是一条消息\n\n#kafka也提供了一个命令行消费者，接受消息并打印到标准输出。\nkafka-console-consume --bootstrap-server localhost:2181 --topic test --from-beginning\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>配置文件位置</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">&#x2F;usr&#x2F;local&#x2F;etc&#x2F;kafka&#x2F;server.properties\n&#x2F;usr&#x2F;local&#x2F;etc&#x2F;kafka&#x2F;zookeeper.properties<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h2 id=\"Kafka-架构\"><a href=\"#Kafka-架构\" class=\"headerlink\" title=\"Kafka 架构\"></a>Kafka 架构</h2><p><strong>BrokerKafka</strong> 集群包含一个或多个服务器，这种服务器被称为 broker<br><strong>Topic</strong> 逻辑上的概念,每条发布到 Kafka 集群的消息都有一个类别，这个类别被称为 Topic。（物理上不同 Topic 的消息分开存储，逻辑上一个 Topic 的消息虽然保存于一个或多个 broker 上但用户只需指定消息的 Topic 即可生产或消费数据而不必关心数据存于何处）<br><strong>Partition</strong> 是物理上的概念，每个 Topic 包含一个或多个 Partition.<br><strong>Producer</strong> 负责发布消息到 Kafka broker<br><strong>Consumer</strong> 消息消费者，向 Kafka broker 读取消息的客户端。<br><strong>Consumer Group</strong> 每个 Consumer 属于一个特定的 Consumer Group（可为每个 Consumer 指定 group name，若不指定 group name 则属于默认的 group）。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>对于传统的 message queue 而言，一般会删除已经被消费的消息，而 Kafka 集群会保留所有的消息，无论其被消费与否。<br>当然，因为磁盘限制，不可能永久保留所有数据（实际上也没必要），因此 Kafka 提供两种策略删除旧数据。</p>\n<blockquote>\n<p>一是基于时间，<br>二是基于 Partition 文件大小。</p></blockquote>\n<p>例如可以通过配置 $KAFKA_HOME&#x2F;config&#x2F;server.properties，让 Kafka 删除一周前的数据，也可在 Partition 文件超过 1GB 时删除旧数据</p>\n</blockquote>\n<h2 id=\"Kafka-特性\"><a href=\"#Kafka-特性\" class=\"headerlink\" title=\"Kafka 特性\"></a>Kafka 特性</h2><ol>\n<li><p>高可用 HA</p>\n<p> 通过 Zookeeper, 主节点挂了，从节点进行选举</p>\n</li>\n<li><p>负载均衡 fail over</p>\n<p> 通过hash 算法 将 key 路由到 不同的分区<br> Zookeeper允许集群中节点失败（若副本数量为n,则允许n-1个节点失败）</p>\n</li>\n<li><p>可扩展</p>\n<p> kafka集群支持 broker 水平扩展，热扩展</p>\n</li>\n<li><p>高吞吐率,低延时</p>\n<p> kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒，每个topic可以分多个partition, consumer group 对partition进行consume操作。<br> 高吞吐率 与 延时 是两个 相悖的概念，如果没2ms 处理 1条消息， 吞吐率 &#x3D; 500条消息&#x2F;s<br> 如果采用批处理，延时8ms发送100 条消息，相当于 （8+2）ms发送了 100 条消息， 吞吐率 &#x3D; 10,000&#x2F;s</p>\n<p> Kafka 发送数据：</p>\n<ol>\n<li><p>kafka 收到消息 现将消息写入页缓存中，而后由操作系统将消息写入磁盘</p>\n</li>\n<li><p>Kafka不予文件系统打交道,是交由操作系统将缓存中的数据写入磁盘</p>\n</li>\n<li><p>将数据写入磁盘采用append方式，顺序写入磁盘，效率高</p>\n<p> <img src=\"/post/Kafka-%E5%85%A5%E9%97%A8/speed.png\" alt=\"speed\"></p>\n</li>\n</ol>\n<p> Kafka 消费数据：<br> 4. kafka 消费数据 先从页缓存中读取，如果命中直接返回，不往硬盘中读取 零拷贝技术</p>\n</li>\n<li><p>可靠性</p>\n<p> 消息被持久化到本地磁盘，并且支持数据备份防止数据丢失</p>\n</li>\n<li><p>数据分区</p>\n<p> 消息可以被路由到不同的分区(hash 算法), 分区有 replica, 容错性</p>\n</li>\n<li><p>消费者多线程并行消费,高并发</p>\n<p> 支持数千个客户端同时读写</p>\n</li>\n</ol>\n<h2 id=\"Kafka-基本概念\"><a href=\"#Kafka-基本概念\" class=\"headerlink\" title=\"Kafka 基本概念\"></a>Kafka 基本概念</h2><h3 id=\"Message\"><a href=\"#Message\" class=\"headerlink\" title=\"Message\"></a>Message</h3><p><img src=\"/post/Kafka-%E5%85%A5%E9%97%A8/Kafka%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F.jpg\" alt=\"Kafka消息格式\"></p>\n<p>key: 消息键值  分区时使用<br>value: 消息内容<br>timestamp: 消息发送时间戳,用于流式处理或其他依赖时间的处理语义</p>\n<p>属性: 1字节， 目前只是用了 最低三位 用于保存消息压缩类型，其余五位未使用。<br>     0 无压缩  1 gzip  2 Snappy 3 LZ4</p>\n<ul>\n<li><p>为什么 kafka 消息缓存放在了页缓存,而不是放在 java 堆上</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>JMM 中,对象内存开销相当大。 堆上的数据量越大，GC的性能会下降很多<br>JAVA操作系统默认开启了页缓存机制，也就是说对上保存的对象很可能在页缓存中保留一份，开销大<br>Kafka 直接使用 ByteBuffer,而不是直接使用对象，占用空间少<br>大量使用页缓存而不是使用堆内存，当kafka broker进程崩溃时，堆上数据会消失一部分，而页缓存中的数据依然存在</p></blockquote>\n</li>\n</ul>\n<h3 id=\"topic\"><a href=\"#topic\" class=\"headerlink\" title=\"topic\"></a>topic</h3><p>Topic 是一个逻辑概念,是一个逻辑概念，我们通常用topic来区分业务，</p>\n<p>kafka 中的topic 会被多个消费者订阅，出于性能的考量，kafka 消息并不是 topic-message 两级结构，而是 topic-partation-message 三级结构来分散负载</p>\n<p>topic 下面可以有 多个 partation, 一般 partation 数目 大于等于 3</p>\n<h3 id=\"partation\"><a href=\"#partation\" class=\"headerlink\" title=\"partation\"></a>partation</h3><p><img src=\"/post/Kafka-%E5%85%A5%E9%97%A8/topic-partation.png\" alt=\"topic-partation\"><br>kafka 引入分区的概念 并没有太多的业务含义，而只是单纯的想提高吞吐量，因此创建kafka topic的时候， 可以根据集群配置设置具体的partation数，实现整体性最大化</p>\n<p>partation有自己专属的 分区号，用户唯一能对partation 的操作就是在partation尾部追加写入消息。partation 上的消息都有一个唯一的 offset.用来定位消息</p>\n<h3 id=\"offset\"><a href=\"#offset\" class=\"headerlink\" title=\"offset\"></a>offset</h3><p><img src=\"/post/Kafka-%E5%85%A5%E9%97%A8/%E6%B6%88%E6%81%AF%E4%BD%8D%E7%A7%BB%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E4%BD%8D%E7%A7%BB.jpg\" alt=\"消息位移与消费者位移\"><br>显然，每条消息在 partation 的位置是固定的，但消费该partation 的消费者位移随着消费进度不断前移。</p>\n<p>综上，topic partation offset, 我们 可以通过 &lt;topic, partation, offset&gt; 唯一确定一条消息的位置。</p>\n<h3 id=\"replica\"><a href=\"#replica\" class=\"headerlink\" title=\"replica\"></a>replica</h3><p>kafka  partation 是 有序消息日志， 那么一定不能只有一份日志。否则一旦持有该partaion的broker down了，就会造成数据丢失。 分布式系统必然要实现高可靠性。目前有效地方式–&gt; 数据冗余，也就是备份多份日志。这些备份的日志 在 kafka里称谓 replic。</p>\n<ul>\n<li>当某个topic的replication-factor为N且N大于1时，每个Partition都会有N个副本(Replica)。kafka的replica包含leader与follower。</li>\n<li>Replica的个数小于等于Broker的个数，也就是说，对于每个Partition而言，每个Broker上最多只会有一个Replica，因此可以使用Broker id 指定Partition的Replica。</li>\n<li>所有Partition的Replica默认情况会均匀分布到所有Broker上。</li>\n</ul>\n<p>leader replica 供客户端读写，follower replica 读客户端不可见，一旦 leader replica 所在 broker宕机，就从follower 中通过选举方式 选出一个 leader.</p>\n<h3 id=\"Leader-和-follower\"><a href=\"#Leader-和-follower\" class=\"headerlink\" title=\"Leader 和 follower\"></a>Leader 和 follower</h3><p>kafka 的 replica 分为 leader 和 follower, (取代了 之前的 master slave)</p>\n<p>leader 负责对外提供读写 服务，<br>follower从 leader 同步数据，充当leader的 候补</p>\n<p>kafka保证 同一个 topic 的 多个 partation 一定不会再 同一个 broker上。</p>\n<h3 id=\"ISR\"><a href=\"#ISR\" class=\"headerlink\" title=\"ISR\"></a>ISR</h3><p>IN-SYNC Replica 与 leader replica 保持同步的 replica 集合</p>\n<p>kafka 承诺 只要这个集合中 至少存在一个 replica, 那些‘已提交’状态的数据就不会丢失。 两个关键点:</p>\n<ol>\n<li>ISR 中 至少存在一个 ‘活着的’ replica</li>\n<li>‘已提交’的消息</li>\n</ol>\n<p><img src=\"/post/Kafka-%E5%85%A5%E9%97%A8/ISR.png\" alt=\"ISR\"></p>\n<h2 id=\"Kafka-使用场景\"><a href=\"#Kafka-使用场景\" class=\"headerlink\" title=\"Kafka 使用场景\"></a>Kafka 使用场景</h2><h3 id=\"消息队列\"><a href=\"#消息队列\" class=\"headerlink\" title=\"消息队列\"></a>消息队列</h3><p>message Queue</p>\n<h3 id=\"网络行为日志追踪\"><a href=\"#网络行为日志追踪\" class=\"headerlink\" title=\"网络行为日志追踪\"></a>网络行为日志追踪</h3><p>重建用户行为追踪，用户对网站的点击量大，这时kafka的 超强吞吐量就有了用武之地</p>\n<h3 id=\"审计数据收集\"><a href=\"#审计数据收集\" class=\"headerlink\" title=\"审计数据收集\"></a>审计数据收集</h3><h3 id=\"日志收集\"><a href=\"#日志收集\" class=\"headerlink\" title=\"日志收集\"></a>日志收集</h3><p>kafka 最常用的 使用方式,日志收集 汇总 统计</p>\n<h3 id=\"Event-Sourcing\"><a href=\"#Event-Sourcing\" class=\"headerlink\" title=\"Event Sourcing\"></a>Event Sourcing</h3><h3 id=\"流式处理\"><a href=\"#流式处理\" class=\"headerlink\" title=\"流式处理\"></a>流式处理</h3><p>spark streaming, apache fliink, apache storm</p>\n","text":"英文文档 | 中文文档 Kafka 是由 LinkedIn 开发的一个分布式的消息系统，使用 Scala 编写，它以可水平扩展和高吞吐率而被广泛使用。 Mac 安装kafka# 会自动 安装会依赖zookeeper brew install kafka # 启动 zookeepe...","link":"","photos":[],"count_time":{"symbolsCount":"4.2k","symbolsTime":"4 mins."},"categories":[{"name":"kafka","slug":"kafka","count":4,"path":"api/categories/kafka.json"}],"tags":[{"name":"kafka","slug":"kafka","count":3,"path":"api/tags/kafka.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Mac-%E5%AE%89%E8%A3%85kafka\"><span class=\"toc-text\">Mac 安装kafka</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Kafka-%E6%9E%B6%E6%9E%84\"><span class=\"toc-text\">Kafka 架构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Kafka-%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">Kafka 特性</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Kafka-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">Kafka 基本概念</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Message\"><span class=\"toc-text\">Message</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#topic\"><span class=\"toc-text\">topic</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#partation\"><span class=\"toc-text\">partation</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#offset\"><span class=\"toc-text\">offset</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#replica\"><span class=\"toc-text\">replica</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Leader-%E5%92%8C-follower\"><span class=\"toc-text\">Leader 和 follower</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ISR\"><span class=\"toc-text\">ISR</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Kafka-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">Kafka 使用场景</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97\"><span class=\"toc-text\">消息队列</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BD%91%E7%BB%9C%E8%A1%8C%E4%B8%BA%E6%97%A5%E5%BF%97%E8%BF%BD%E8%B8%AA\"><span class=\"toc-text\">网络行为日志追踪</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%A1%E8%AE%A1%E6%95%B0%E6%8D%AE%E6%94%B6%E9%9B%86\"><span class=\"toc-text\">审计数据收集</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86\"><span class=\"toc-text\">日志收集</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Event-Sourcing\"><span class=\"toc-text\">Event Sourcing</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B5%81%E5%BC%8F%E5%A4%84%E7%90%86\"><span class=\"toc-text\">流式处理</span></a></li></ol></li></ol>","author":{"name":"majm","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"技术分享","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Apache-AB性能测试工具","uid":"ff81db1204df3c00c93bb459f070d6f2","slug":"Apache-AB性能测试工具","date":"2019-04-28T10:03:21.000Z","updated":"2019-04-28T10:08:30.000Z","comments":true,"path":"api/articles/Apache-AB性能测试工具.json","keywords":null,"cover":null,"text":"ApacheAB 官方Doc Apache AB 性能测试工具，这是 apache 免费自带的 性能测试工具, 就在 apache bin目录下，他能模拟多个并发请求，主要用来测试你的 服务每秒能承受多少并发请求。 命令ab -n 3000 -c 3000 http:&#x2F;...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"apacheAB","slug":"apacheAB","count":1,"path":"api/tags/apacheAB.json"},{"name":"并发","slug":"并发","count":1,"path":"api/tags/并发.json"},{"name":"性能测试工具","slug":"性能测试工具","count":1,"path":"api/tags/性能测试工具.json"}],"author":{"name":"majm","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"技术分享","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Spring Bean生命周期","uid":"be477fe08f671338b34bfe6576dd4bfb","slug":"Spring-Bean生命周期","date":"2019-04-16T15:02:12.000Z","updated":"2019-06-04T06:57:21.000Z","comments":true,"path":"api/articles/Spring-Bean生命周期.json","keywords":null,"cover":[],"text":" 本篇文章记录一下Spring中,BeanFactory 与 ApplicationContext 中 bean 的生命周期过程，参考网上资料,总结如下 BeanFactory 当调用者调用 getBean() 想容器请求一个bean时,如果容器注册了 Instantiation...","link":"","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[{"name":"spring","slug":"spring","count":3,"path":"api/categories/spring.json"}],"tags":[{"name":"spring","slug":"spring","count":3,"path":"api/tags/spring.json"},{"name":"bean生命周期","slug":"bean生命周期","count":1,"path":"api/tags/bean生命周期.json"},{"name":"ApplicationContext","slug":"ApplicationContext","count":1,"path":"api/tags/ApplicationContext.json"},{"name":"BeanFactory","slug":"BeanFactory","count":1,"path":"api/tags/BeanFactory.json"}],"author":{"name":"majm","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"技术分享","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}