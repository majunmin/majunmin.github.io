{"title":"六边形架构","uid":"911037a657c82ed3571b8e922dfd713c","slug":"六边形架构","date":"2022-07-23T02:47:02.000Z","updated":"2022-07-23T03:26:42.646Z","comments":true,"path":"api/articles/六边形架构.json","keywords":null,"cover":[],"content":"<p>分层架构是一种架构风格,本质是避免耦合,使边界清晰.<br>六边形架构 遵循了分层架构的所有约束与特性，其实使用 端口与适配器这个名字更加合适.因为六边形架构的 边数没有意义.</p>\n<p>六边形架构能够充分地区分 领域模型与 输入输出设备之间的界限.</p>\n<p><img src=\"/./%E5%85%AD%E8%BE%B9%E5%BD%A2%E6%9E%B6%E6%9E%84/%E5%85%AD%E8%BE%B9%E5%BD%A2%E6%9E%B6%E6%9E%84.png\" alt=\"六边形架构\"></p>\n<span id=\"more\"></span>\n\n\n<h2 id=\"1-六边形架构-端口与适配器\"><a href=\"#1-六边形架构-端口与适配器\" class=\"headerlink\" title=\"1. 六边形架构(端口与适配器)\"></a>1. 六边形架构(端口与适配器)</h2><ol>\n<li>一种具有对称性特征的架构风格</li>\n<li>在这种架构中不同的客户通过”平等”的方式与系统交互</li>\n<li>新客户的加入,只需要添加一个新的适配器将客户输入转化成能被系统 API 所理解的参数就行了</li>\n<li>系统输出(图形界面、持久化和消息等)都有一个新建的适配器负责完成相应的转化功能.</li>\n</ol>\n<h2 id=\"2-六边形架构的概念\"><a href=\"#2-六边形架构的概念\" class=\"headerlink\" title=\"2. 六边形架构的概念\"></a>2. 六边形架构的概念</h2><h3 id=\"实体-Entity\"><a href=\"#实体-Entity\" class=\"headerlink\" title=\"实体 Entity\"></a>实体 Entity</h3><p>领域对象的一个 Snapshot.  他不知道自身的存储位置.</p>\n<h3 id=\"存储器-Repositories\"><a href=\"#存储器-Repositories\" class=\"headerlink\" title=\"存储器 Repositories\"></a>存储器 Repositories</h3><p>是获取实体及创建和更改实体的 <code>interface</code>.它们保存一系列方法,用来与数据源通信并返回单个实体或实体列表</p>\n<h3 id=\"交互器-Interactors\"><a href=\"#交互器-Interactors\" class=\"headerlink\" title=\"交互器 Interactors\"></a>交互器 Interactors</h3><p>是用来编排和执行域动作(domain action),的类——可以考虑服务对象或用例对象.它们实现复杂的业务规则和针对特定域动作的验证逻辑.</p>\n<h3 id=\"数据源-Datasource\"><a href=\"#数据源-Datasource\" class=\"headerlink\" title=\"数据源 Datasource\"></a>数据源 Datasource</h3><p>是针对不同 Repository 实现的适配器(Adaptor). 数据源可能是 SQL 数据库的适配器弹性搜索适配器,REST API,CSV 文件, 或者 Hash表 之类的简单适配器.   数据源实现在 Repository 上定义的方法, 并存储获取和推送数据的实现.</p>\n<h3 id=\"层-领域层\"><a href=\"#层-领域层\" class=\"headerlink\" title=\"层: 领域层\"></a>层: 领域层</h3><p>领域模型包含了所有的应用逻辑与规则.</p>\n<p>领域层中不会直接引用技术实现(细节),例如 HTTP 上下文或数据库调用,这样就能够确保在技术方面的改动不会影响到领域层面.</p>\n<h3 id=\"层-端口层\"><a href=\"#层-端口层\" class=\"headerlink\" title=\"层:  端口层\"></a>层:  端口层</h3><p>负责接收与<code>用例</code>相关的所有请求,这些请求负责在领域层中协调工作</p>\n<p>端口层在端口内部作为领域层的边界,在端口外部则扮演了外部实体的角色.</p>\n<h3 id=\"层-适配器层\"><a href=\"#层-适配器层\" class=\"headerlink\" title=\"层: 适配器层\"></a>层: 适配器层</h3><p>这一层的技术实现负责以某种格式接收输入,及产生输出.</p>\n<p>在适配器层不存在领域逻辑,它的唯一职责就是在外部世界与领域层之间进行技术性的转换.</p>\n<h2 id=\"3-六边形架构的优点\"><a href=\"#3-六边形架构的优点\" class=\"headerlink\" title=\"3. 六边形架构的优点\"></a>3. 六边形架构的优点</h2><ul>\n<li>可以轻易的开发用于测试的适配器。</li>\n<li>应用程序和领域模型可以在没有客户和存储机制的条件下进行设计开发</li>\n<li>任何测试客户都可以在用户解密还未完成之前进行开发</li>\n<li>选择持久化机制之前，可以在测试中采用内存资源库来模拟持久化</li>\n<li>如此可以在核心领域上进行持续开发,不需要考虑那些支撑性的技术组件</li>\n</ul>\n<h2 id=\"4-六边形架构的核心思想\"><a href=\"#4-六边形架构的核心思想\" class=\"headerlink\" title=\"4.  六边形架构的核心思想\"></a>4.  六边形架构的核心思想</h2><h3 id=\"关注点分离\"><a href=\"#关注点分离\" class=\"headerlink\" title=\"关注点分离\"></a>关注点分离</h3><ul>\n<li>重心放在领域业务逻辑上, 因为<code>领域</code>的业务逻辑相对更加稳定,体现应用的核心价值,应当优先详尽的设计与测试.</li>\n<li>外部的输入驱动逻辑和输出给外部的被驱动逻辑存在可变性,可替换性,同时可以依赖多种不同的具体技术实现,可以在后一个阶段考虑.</li>\n<li>实际研发过程中还存在输出的外部系统还没有设计与开发好的情况,此时在节奏上也不匹配,可能只有对方的设计文档,甚至更严重的情况下设计文档都没</li>\n<li>输出的外部系统存在多种不同类型的可能,例如在有些情况下你对接的是 OpenStack,有些情况下对接的是 VMware 。</li>\n</ul>\n<h3 id=\"外部可替换\"><a href=\"#外部可替换\" class=\"headerlink\" title=\"外部可替换\"></a>外部可替换</h3><p>内部不关心外部如何使用端口， 外部使用者是可替换的这个原则一开始设计的时候就需要遵守。<br>适配器可以分为2类，“驱动者适配器”和“被驱动者适配器”，也可以称为“输入型适配器”和“输出型适配器”。<br>输出型适配器从表面上看似乎是内部在使用外部，与外部可替换的原则有冲突，这个问题实际上需要通过“依赖倒置”解决。</p>\n<h3 id=\"依赖倒置\"><a href=\"#依赖倒置\" class=\"headerlink\" title=\"依赖倒置\"></a>依赖倒置</h3><p>Adapter  + Repository</p>\n<h3 id=\"可测试性\"><a href=\"#可测试性\" class=\"headerlink\" title=\"可测试性\"></a>可测试性</h3><ul>\n<li>内六边形中的应用程序应当可以在不依赖外部的情况下自行测试.</li>\n<li>通过 接口可以 方便的 进行 mock.</li>\n</ul>\n<hr>\n<p>[参考]<br><a href=\"https://zhuanlan.zhihu.com/p/378085465\">六边形架构的理解</a><br><a href=\"https://www.infoq.cn/article/2014/11/exploring-hexagonal-architecture\">探索六边形架构</a><br><a href=\"https://www.cnblogs.com/zhongpan/p/7606430.html\">深入理解六边形架构</a><br><a href=\"https://www.infoq.cn/article/pjekymkzhmkafgi6ycri\">Netflix 的六边形架构实践</a></p>\n","text":"分层架构是一种架构风格,本质是避免耦合,使边界清晰.六边形架构 遵循了分层架构的所有约束与特性，其实使用 端口与适配器这个名字更加合适.因为六边形架构的 边数没有意义. 六边形架构能够充分地区分 领域模型与 输入输出设备之间的界限. 1. 六边形架构(端口与适配器) 一种具有对称...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"架构","slug":"架构","count":2,"path":"api/tags/架构.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E5%85%AD%E8%BE%B9%E5%BD%A2%E6%9E%B6%E6%9E%84-%E7%AB%AF%E5%8F%A3%E4%B8%8E%E9%80%82%E9%85%8D%E5%99%A8\"><span class=\"toc-text\">1. 六边形架构(端口与适配器)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E5%85%AD%E8%BE%B9%E5%BD%A2%E6%9E%B6%E6%9E%84%E7%9A%84%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">2. 六边形架构的概念</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E4%BD%93-Entity\"><span class=\"toc-text\">实体 Entity</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AD%98%E5%82%A8%E5%99%A8-Repositories\"><span class=\"toc-text\">存储器 Repositories</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%A4%E4%BA%92%E5%99%A8-Interactors\"><span class=\"toc-text\">交互器 Interactors</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E6%BA%90-Datasource\"><span class=\"toc-text\">数据源 Datasource</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B1%82-%E9%A2%86%E5%9F%9F%E5%B1%82\"><span class=\"toc-text\">层: 领域层</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B1%82-%E7%AB%AF%E5%8F%A3%E5%B1%82\"><span class=\"toc-text\">层:  端口层</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B1%82-%E9%80%82%E9%85%8D%E5%99%A8%E5%B1%82\"><span class=\"toc-text\">层: 适配器层</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E5%85%AD%E8%BE%B9%E5%BD%A2%E6%9E%B6%E6%9E%84%E7%9A%84%E4%BC%98%E7%82%B9\"><span class=\"toc-text\">3. 六边形架构的优点</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E5%85%AD%E8%BE%B9%E5%BD%A2%E6%9E%B6%E6%9E%84%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3\"><span class=\"toc-text\">4.  六边形架构的核心思想</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB\"><span class=\"toc-text\">关注点分离</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%96%E9%83%A8%E5%8F%AF%E6%9B%BF%E6%8D%A2\"><span class=\"toc-text\">外部可替换</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE\"><span class=\"toc-text\">依赖倒置</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E6%B5%8B%E8%AF%95%E6%80%A7\"><span class=\"toc-text\">可测试性</span></a></li></ol></li></ol>","author":{"name":"majm","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"技术分享","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"洋葱架构","uid":"2797f253c04e63756fe2c781cd7fcc62","slug":"洋葱架构","date":"2022-07-23T06:23:04.000Z","updated":"2022-07-23T07:38:07.305Z","comments":true,"path":"api/articles/洋葱架构.json","keywords":null,"cover":[],"text":" 领域是一个知识范畴,他指的是我们的软件要模拟的业务知识。 领域驱动设计的核心是 领域模型,它对一个领域的流程和规则有着深刻的理解,洋葱架构实现了这一概念,并极大地改善了代码的品质,降低了复杂性,并且支持不断地发展企业系统. 详解”洋葱架构”Onion Architecture ...","link":"","photos":[],"count_time":{"symbolsCount":143,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"架构","slug":"架构","count":2,"path":"api/tags/架构.json"}],"author":{"name":"majm","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"技术分享","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"位运算-基础","uid":"0fbff2d6e80a66fc76d63bc97dc872bd","slug":"位运算-基础","date":"2022-07-19T15:29:47.000Z","updated":"2022-07-23T04:15:53.391Z","comments":true,"path":"api/articles/位运算-基础.json","keywords":null,"cover":null,"text":" 异或操作x ^ 0 &#x3D; x x ^ 1s &#x3D; ~x &#x2F;&#x2F; 1s &#x3D; ~0 x ^ ~x &#x3D; 1s x ^ x &#x3D; 0 c &#x3D; a ^ b &#x3D;&gt; a ^ c &#x3D; b, b ^...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"算法","slug":"算法","count":2,"path":"api/tags/算法.json"},{"name":"位运算","slug":"位运算","count":1,"path":"api/tags/位运算.json"}],"author":{"name":"majm","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"技术分享","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}