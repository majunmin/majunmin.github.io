{"title":"《架构整洁之道》-读书笔记:7-11章","uid":"5ed57e13aea17add1dca2c51e84aa68f","slug":"《架构整洁之道》-读书笔记-7-11章","date":"2022-07-09T06:01:58.000Z","updated":"2022-10-10T16:06:20.546Z","comments":true,"path":"api/articles/《架构整洁之道》-读书笔记-7-11章.json","keywords":null,"cover":[],"content":"<h1 id=\"《架构整洁之道》-读书笔记-7-11章\"><a href=\"#《架构整洁之道》-读书笔记-7-11章\" class=\"headerlink\" title=\"《架构整洁之道》-读书笔记:7-11章\"></a>《架构整洁之道》-读书笔记:7-11章</h1><p>架构整洁之道: 第 7-11 章 主要讲的是 设计原则, <code>SOLID</code>,<br><code>SOLID</code> 的主要作用是告诉我们如何将数据和函数组织称为类,以及如何将这些类链接起来组合成一个程序.</p>\n<p>软件构建中层模块主要目标如下:</p>\n<ul>\n<li>使软件可容忍被改动.</li>\n<li>是软件更容易被理解.</li>\n<li>构建在多个系统中复用的组件.</li>\n</ul>\n<p><code>SOLID</code> 原则应该紧贴于代码实现之上,这些原则主要是帮助我们定义软件架构中组件和模块的.</p>\n<ul>\n<li>SRP  Single Resposibility Principle<br>每个软件应该有且仅有一个被修改的理由.</li>\n<li>OCP  Open Close Principle<br>如果软件系统想要更容易被改变,那么设计就必须允许新增代码来修改系统行为,而非只能靠修改原来的代码.</li>\n<li>LSP  Liskov Substitution Principle<br>利用可替换的组件构建软件系统,那么这些组件就必须遵循同一个约定,以便让谢谢组件可以相互替换.</li>\n<li>ISP  Interface Segregation Principle<br>在设计中避免不必要的依赖.</li>\n<li>DIP  Depencency Inverse Principle<br>高层策略性的代码不应该依赖实现底层细节的代码,恰恰相反,那些实现底层细节的代码应该依赖高层策略性的代码.</li>\n</ul>\n<span id=\"more\"></span>\n\n\n<h2 id=\"SRP-单一职责原则\"><a href=\"#SRP-单一职责原则\" class=\"headerlink\" title=\"SRP 单一职责原则\"></a>SRP 单一职责原则</h2><p>最重要的一个原则, 其他原则也基本是上都与这个原则有关.<br>《架构整洁之道》这本书中的例子讲的很好</p>\n<p>任何一个软件模块都应该有且仅有一个被修改的原因.</p>\n<p>任何一个软件模块都应该只对某一类行为者负责.</p>\n<p>多人为了不同的目的修改了同一份源代码,这很容易造成问题的产生. 而避免这种问题产生的方法就是将服务不同行为者的代码进行切分.</p>\n<h2 id=\"OCP-开闭原则\"><a href=\"#OCP-开闭原则\" class=\"headerlink\" title=\"OCP 开闭原则\"></a>OCP 开闭原则</h2><p>设计良好的计算机软件应该易于扩展, 同时抗拒修改.</p>\n<p>如果A组件不想被B组件上发生的修改所影响, 那么就应该让B组件依赖于A组件.</p>\n<p>软件系统不应该依赖其不直接使用的组件</p>\n<p>OCP是我们进行系统架构设计的主导原则,其主要目标是让系统易于扩展,同时限制其每次被修改所影响的范围.实现方式是通过将系统划分为一系列组件,并且将这些组件间的依赖关系按层次结构进行组织,使得高阶组件不会因低阶组件被修改而受到影响.</p>\n<h2 id=\"LSP-里氏替换原则\"><a href=\"#LSP-里氏替换原则\" class=\"headerlink\" title=\"LSP  里氏替换原则\"></a>LSP  里氏替换原则</h2><p>果对于每个类型是S的对象o1都存在一个类型为T的对象o2,能使操作T类型的程序P在用o2替换o1时行为保持不变,我们就可以将S称为T的子类型.(指导类的设计)</p>\n<p>LSP可以且应该被应用于软件架构层面,因为一旦违背了可替换性,该系统架构就不得不为此增添大量复杂的应对机制.</p>\n<h2 id=\"ISP-接口隔离原则\"><a href=\"#ISP-接口隔离原则\" class=\"headerlink\" title=\"ISP 接口隔离原则\"></a>ISP 接口隔离原则</h2><p>任何层次的软件设计如果依赖了它并不需要的东西.就会带来意料之外的麻烦.</p>\n<p>目的是为了解耦,不依赖其不需要的系统,避免牵一发而动全身.</p>\n<p><img src=\"/post/%E3%80%8A%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-7-11%E7%AB%A0/isp-1.png\"></p>\n<p><img src=\"/post/%E3%80%8A%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-7-11%E7%AB%A0/isp-2.png\"></p>\n<h2 id=\"DIP-依赖反转原则\"><a href=\"#DIP-依赖反转原则\" class=\"headerlink\" title=\"DIP  依赖反转原则\"></a>DIP  依赖反转原则</h2><p>如果想要设计一个灵活的系统,在源代码层次的依赖关系中就应该多引用抽象类型,而非具体实现.</p>\n<p>在应用DIP时,我们也不必考虑稳定的操作系统或者平台设施,因为这些系统接口很少会有变动.我们主要应该关注的是软件系统内部那些会经常变动的(volatile)具体实现模块,这些模块是不停开发的,也就会经常出现变更.</p>\n<h3 id=\"稳定的抽象层\"><a href=\"#稳定的抽象层\" class=\"headerlink\" title=\"稳定的抽象层\"></a>稳定的抽象层</h3><p>应在代码中多使用抽象接口，尽量避免使用那些多变的具体实现类. (抽象工厂)<br>不要在具体实现类上创建衍生类.<br>不要覆盖（override）包含具体实现的函数.在这里,控制依赖关系的唯一办法,就是创建一个抽象函数,然后再为该函数提供多种具体实现. (不要引入源代码层级的依赖)<br>应避免在代码中写入与任何具体实现相关的名字,或者是其他容易变动的事物的名字.</p>\n<h3 id=\"🏭工厂模式\"><a href=\"#🏭工厂模式\" class=\"headerlink\" title=\"🏭工厂模式\"></a>🏭工厂模式</h3><p>如果要创建出一个稳定的抽象层, 要对那些容易变的对象的创建过程做一些特殊处理. (因为基本在所有的编程语言中,对象的创建都免不了源代码层级上依赖对象的具体实现.)<br>一般场景下,使用抽象工厂模式解决源代码层级依赖的问题.</p>\n<p><img src=\"/post/%E3%80%8A%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-7-11%E7%AB%A0/factory.png\"><br>中间那条曲线代表了软件架构中抽象层与具体实现层之间的边界,这里,所有跨越这条边界的源代码级别的依赖关系都应该是单向的. 也即具体实现依赖于抽象.</p>\n<hr>\n<p>[参考]<br><a href=\"https://time.geekbang.org/column/intro/100039001\">极客时间-设计模式之美</a><br><a href=\"https://www.aliyundrive.com/s/sPzz5LhPX22\">架构整洁之道-阿里云盘</a></p>\n","text":"《架构整洁之道》-读书笔记:7-11章架构整洁之道: 第 7-11 章 主要讲的是 设计原则, SOLID,SOLID 的主要作用是告诉我们如何将数据和函数组织称为类,以及如何将这些类链接起来组合成一个程序. 软件构建中层模块主要目标如下: 使软件可容忍被改动. 是软件更容易被理...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"读书笔记","slug":"读书笔记","count":1,"path":"api/tags/读书笔记.json"},{"name":"架构整洁之道","slug":"架构整洁之道","count":1,"path":"api/tags/架构整洁之道.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E3%80%8A%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-7-11%E7%AB%A0\"><span class=\"toc-text\">《架构整洁之道》-读书笔记:7-11章</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#SRP-%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">SRP 单一职责原则</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#OCP-%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">OCP 开闭原则</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#LSP-%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">LSP  里氏替换原则</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ISP-%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">ISP 接口隔离原则</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#DIP-%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">DIP  依赖反转原则</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A8%B3%E5%AE%9A%E7%9A%84%E6%8A%BD%E8%B1%A1%E5%B1%82\"><span class=\"toc-text\">稳定的抽象层</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%F0%9F%8F%AD%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">🏭工厂模式</span></a></li></ol></li></ol></li></ol>","author":{"name":"majm","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"技术分享","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"位运算-基础","uid":"0fbff2d6e80a66fc76d63bc97dc872bd","slug":"位运算-基础","date":"2022-07-19T15:29:47.000Z","updated":"2022-07-23T04:15:53.391Z","comments":true,"path":"api/articles/位运算-基础.json","keywords":null,"cover":null,"text":" 异或操作x ^ 0 &#x3D; x x ^ 1s &#x3D; ~x &#x2F;&#x2F; 1s &#x3D; ~0 x ^ ~x &#x3D; 1s x ^ x &#x3D; 0 c &#x3D; a ^ b &#x3D;&gt; a ^ c &#x3D; b, b ^...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"算法","slug":"算法","count":2,"path":"api/tags/算法.json"},{"name":"位运算","slug":"位运算","count":1,"path":"api/tags/位运算.json"}],"author":{"name":"majm","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"技术分享","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Intelij-快捷键","uid":"8f865e6ecd68910430d22fc2c9ae4d28","slug":"Intelij-快捷键","date":"2022-07-07T03:20:28.000Z","updated":"2022-10-08T10:33:41.365Z","comments":true,"path":"api/articles/Intelij-快捷键.json","keywords":null,"cover":null,"text":"常用快捷键 Ctrl + Command + G : 选中所有相同的的内容 Ctrl + G : 选中下一个相同的内容 ","link":"","photos":[],"count_time":{"symbolsCount":76,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Intelij","slug":"Intelij","count":1,"path":"api/tags/Intelij.json"},{"name":"快捷键","slug":"快捷键","count":1,"path":"api/tags/快捷键.json"}],"author":{"name":"majm","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"技术分享","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}