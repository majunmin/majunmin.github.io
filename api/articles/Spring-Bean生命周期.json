{"title":"Spring Bean生命周期","uid":"be477fe08f671338b34bfe6576dd4bfb","slug":"Spring-Bean生命周期","date":"2019-04-16T15:02:12.000Z","updated":"2019-06-04T06:57:21.000Z","comments":true,"path":"api/articles/Spring-Bean生命周期.json","keywords":null,"cover":[],"content":"<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>本篇文章记录一下Spring中,BeanFactory 与 ApplicationContext 中 bean 的生命周期过程，参考网上资料,总结如下</p></blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"BeanFactory\"><a href=\"#BeanFactory\" class=\"headerlink\" title=\"BeanFactory\"></a>BeanFactory</h2><img src=\"/post/Spring-Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/BeanFactory%E4%B8%ADBean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png\" class=\"\" title=\"BeanFactory中Bean生命周期\">\n\n<ol>\n<li><p>当调用者调用 <code>getBean()</code> 想容器请求一个bean时,如果容器注册了 InstantiationAwareBeanPostProcessor(实现了BeanPostProcessor)接口,<br>则实例化bean之前，调用该接口的 <code>postProcessBeforeInstantiation()</code></p>\n</li>\n<li><p>根据配置调用bean的构造器&#x2F;工厂方法 实例化bean</p>\n</li>\n<li><p>如果容器注册了 InstantiationAwareBeanPostProcessor(实现了BeanPostProcessor)接口, 则实例化bean之后，调用该接口的 <code>postProcessAfterInstantiation()</code></p>\n</li>\n<li><p>如果bean配置了 属性信息， 则 这一步将属性设置到bean对应的属性中， 在设置每一个属性值之前, 调用 InstantiationAwareBeanPostProcessor 的 postProcessPropertyValues()</p>\n</li>\n<li><p>设置属性值</p>\n</li>\n<li><p>如果bean  实现了 BeanNameAware 接口，则  执行 setBeanName()，将xml文件里的 beanid 设置到 bean中</p>\n</li>\n<li><p>如果bean  实现了 BeanFactoryAware 接口，则  执行 setBeanFactory()，将BeanFactory 容器实例 设置到 bean中</p>\n</li>\n<li><p>如果 beanFactory 装配了 BeanPostProcessor 接口，则 调用 BeanPostProcessor.postProcessBeforeInitialization(Object bean, String beanName)对bean进行加工<br> bean: 当前增在处理的 bean  beanName: 当前bean的配置名  返回值为 加工处理后的bean</p>\n</li>\n</ol>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>要使用BeanPostProcessor回调，就必须先在容器中注册实现该接口的类，那么如何注册呢？<br>BeanFactory和ApplicationContext容器的注册方式不大一样：若使用BeanFactory，则必须要显示的调用其addBeanPostProcessor()方法进行注册，<br>参数为BeanPostProcessor实现类的实例；如果是使用ApplicationContext，那么容器会在配置文件在中自动寻找实现了BeanPostProcessor接口的Bean，然后自动注册，<br>我们要做的只是配置一个BeanPostProcessor实现类的Bean就可以了。</p></blockquote>\n<ol start=\"9\">\n<li><p>如果bean实现了 InitializingBean 接口 ，则调用 InitializingBean#afterProperiesSet</p>\n</li>\n<li><p>如果在bean中通过init-method属性定义了初始化方法，则将执行这个方法。</p>\n</li>\n<li><p>BeanPostProcessor 后处理利器定义了两个方法， postProcessBeforeInitialization(8 中调用)  postProcessAfterInitialization(Object bean, String beanName)<br>此方法调用时 spring 再次获得 对bean进行加工处理的机会</p>\n</li>\n<li><p>如果 <bean> 中定义 bean 的作用范围是 scope&#x3D;’prototype’, 则将bean返回给调用者，由调用者负责bean后续生命周期管理，spring不在管理这个bean的生命周期<br>如果 <bean> 中定义 bean 的作用范围是 scope&#x3D;’singleton’,当将bean 放入SpringIOC容器的缓存池中， 并将 bean 引用返回给调用者，spring继续对 bean 进行后续的生命周期管理</p>\n</li>\n<li><p>如果当前的bean的作用范围是singleton，且bean实现了DisposableBean接口，在容器关闭的时候，则将调用接口的destory方法。</p>\n</li>\n<li><p>对于singleton的bean，如果bean通过destory-method属性指定了bean的销毁方法，那么在spring容器关闭的时候，就会执行该方法。</p>\n</li>\n</ol>\n<h3 id=\"这些方法大致可以归为四类：\"><a href=\"#这些方法大致可以归为四类：\" class=\"headerlink\" title=\"这些方法大致可以归为四类：\"></a>这些方法大致可以归为四类：</h3><ol>\n<li>Bean自身的方法：自身的方法也就是在bean中通过init-method和destory-method指定的方法。</li>\n<li>Bean级生命周期接口方法：如BeanNameAware，BeanFactoryAware，InitializingBean和DisposableBean，这些接口方法由Bean类直接实现。</li>\n<li>容器级生命周期接口方法：InstantiationAwareBeanPostProcessor和BeanPostProcessor接口实现，一般称它们的实现类为“后处理器”。<ul>\n<li>后处理器接口一般不由bean实现, 他们独立于bean, 一般以容器附加的形式注册到 spring容器中，并通过接口反射为spring容器扫描识别，</li>\n<li>当容器创建任何bean的时候后处理器都会发生作用。所以这些后处理器的影响是全局性的</li>\n<li>当然用户可以合理的编写后处理器，使其只对感兴趣的bean进行处理</li>\n</ul>\n</li>\n<li>工厂处理器接口方法：包括AspectJWeavingEnabler，CustomAutowireConfigurer，ConfigurationClassPostProcessor等方法。工厂后处理器也是容器级的，在应用上下文装配文件后立即调用。</li>\n</ol>\n<h2 id=\"ApplicationContext\"><a href=\"#ApplicationContext\" class=\"headerlink\" title=\"ApplicationContext\"></a>ApplicationContext</h2><p>使用ApplicationContext &amp; bean(scope&#x3D;singleton) ,name容器加载时这些bean 就会被实例化。好处是可以预先加载，缺点是耗内存<br>如果使用的是 BeanFactory, 当实例化bean时不会直接实例化，而是等到使用(调动 getBean(String beanName))时才会实例化. BeanFactory会延迟初始化所投的的Bean. 好处是节约内存, 缺点是速度慢</p>\n<p>一般没有特殊要求，使用ApplicationContext. ApplicationContext 实现了 ListableBeanFactory &amp; HierarchicalBeanFactory,具有BeanFactory的所有功能， 并且还额外提供了 许多高级功能</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">ApplicationContext</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">EnvironmentCapable</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">ListableBeanFactory</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">HierarchicalBeanFactory</span><span class=\"token punctuation\">,</span>\n\t\t<span class=\"token class-name\">MessageSource</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">ApplicationEventPublisher</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">ResourcePatternResolver</span> <span class=\"token punctuation\">&#123;</span>\n\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n<ul>\n<li>提供文本解析工具，包括对国际化的支持</li>\n<li>提供载入资源文件的通用方法，图片</li>\n<li>可以向注册为监听器的Bean 发送事件</li>\n</ul>\n<p>ApplicationContext 经常见到的三种实现<br>    <code>ClassPathXmlApplicationContext</code>   从类路径中加载。<br>    <code>FileSystemXmlApplicationContext</code>  从文件系统加载。<br>    <code>XmlWebApplicationContext</code>         从Web系统中加载。</p>\n<p>ApplicationContext中 bean生命周期 与 BeanFactory中 Bean生命周期类似<br>不同得是 如果bean实现了 ApplicationContextAware 接口， 将调用 setApplicationContext()</p>\n<p>此外如果配置文件中配置了工厂后处理器接口,<code>BeanFactoryPostProcessor</code> 的实现类,则应用上下文装配完配置文件之后,初始化bean之前，会调用这些BeanFactoryPostProcessor对配置信息进行加工处理,如<code>CustomerEditorConfigure</code>, <code>PropertyPlaceHolderConfigure</code>. 如果配置了多个最好实现 Order 接口,spring可以按顺序执行他们。这些实现的作用是什么呢？<br>工厂后处理器是容器级别的,仅在应用上下文初始化时调用一次,其目的是完成一些配置文件的加工处理工作。</p>\n<p>ApplicationContext在启动时,将首先为配置文件中的每个bean生成BeanDefination对象，BeanDefination<bean>在spirng容器中的内部表示。当配置文件中所有的bean都被解析成BeanDefination时，ApplicationContext将调用工厂后处理器方法。因此我们有机会通过程序的方式调整bean的配置信息。</p>\n<img src=\"/post/Spring-Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/ApplicationContext%E4%B8%ADBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg\" class=\"\" title=\"ApplicationContext中bean的生命周期\">\n\n<p>bean的生命周期不但和其实现的接口有关，还和它的作用范围相关。</p>\n","text":" 本篇文章记录一下Spring中,BeanFactory 与 ApplicationContext 中 bean 的生命周期过程，参考网上资料,总结如下 BeanFactory 当调用者调用 getBean() 想容器请求一个bean时,如果容器注册了 Instantiation...","link":"","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[{"name":"spring","slug":"spring","count":3,"path":"api/categories/spring.json"}],"tags":[{"name":"spring","slug":"spring","count":3,"path":"api/tags/spring.json"},{"name":"bean生命周期","slug":"bean生命周期","count":1,"path":"api/tags/bean生命周期.json"},{"name":"ApplicationContext","slug":"ApplicationContext","count":1,"path":"api/tags/ApplicationContext.json"},{"name":"BeanFactory","slug":"BeanFactory","count":1,"path":"api/tags/BeanFactory.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#BeanFactory\"><span class=\"toc-text\">BeanFactory</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%99%E4%BA%9B%E6%96%B9%E6%B3%95%E5%A4%A7%E8%87%B4%E5%8F%AF%E4%BB%A5%E5%BD%92%E4%B8%BA%E5%9B%9B%E7%B1%BB%EF%BC%9A\"><span class=\"toc-text\">这些方法大致可以归为四类：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ApplicationContext\"><span class=\"toc-text\">ApplicationContext</span></a></li></ol>","author":{"name":"majm","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"技术分享","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Kafka 入门","uid":"937bc65e7fc0650a79730217f9c7b325","slug":"Kafka-入门","date":"2019-04-28T07:08:15.000Z","updated":"2022-03-03T15:51:22.323Z","comments":true,"path":"api/articles/Kafka-入门.json","keywords":null,"cover":[],"text":"英文文档 | 中文文档 Kafka 是由 LinkedIn 开发的一个分布式的消息系统，使用 Scala 编写，它以可水平扩展和高吞吐率而被广泛使用。 Mac 安装kafka# 会自动 安装会依赖zookeeper brew install kafka # 启动 zookeepe...","link":"","photos":[],"count_time":{"symbolsCount":"4.2k","symbolsTime":"4 mins."},"categories":[{"name":"kafka","slug":"kafka","count":4,"path":"api/categories/kafka.json"}],"tags":[{"name":"kafka","slug":"kafka","count":3,"path":"api/tags/kafka.json"}],"author":{"name":"majm","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"技术分享","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{}}