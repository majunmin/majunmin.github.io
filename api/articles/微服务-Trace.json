{"title":"微服务 Trace","uid":"9a85a1a2b7a6a9bc3209cb287c73c69a","slug":"微服务-Trace","date":"2022-08-18T04:46:07.000Z","updated":"2022-08-29T08:51:32.897Z","comments":true,"path":"api/articles/微服务-Trace.json","keywords":null,"cover":null,"content":"<h2 id=\"Spection-Trace-语义\"><a href=\"#Spection-Trace-语义\" class=\"headerlink\" title=\"Spection  Trace 语义\"></a>Spection  Trace 语义</h2><h3 id=\"Trace\"><a href=\"#Trace\" class=\"headerlink\" title=\"Trace\"></a>Trace</h3><p>代表一个调用链.</p>\n<p>通常， 一个 Trace 可以被理解为一系列span 组成的有向无环图(DAG), span 之间的边称为  Reference.</p>\n<h3 id=\"Span\"><a href=\"#Span\" class=\"headerlink\" title=\"Span\"></a>Span</h3><p><code>Span</code> 表示一个跨进程的 RPC 或者进程内部的一个过程.</p>\n<p>每个span 可以包含一些状态:<br><code>operate_name</code><br><code>start_timestampe</code><br><code>end_timestamp</code><br><code>Tags</code>: 一系列 kv 集合<br><code>Logs</code>: 一系列 kv 集合,并且携带时间戳<br><code>SpanContext</code>:<br><code>Reference</code>: 通过 SpanContext 关联其他 Span</p>\n<h3 id=\"SpanContext\"><a href=\"#SpanContext\" class=\"headerlink\" title=\"SpanContext\"></a>SpanContext</h3><p>SpanContext  封装了一个可以用来指向特定 Span 的状态,用于在进程间(内)传递. 通过在进程间传递,在分布式环境中构建一个DAG图.</p>\n<p>span 必须去提供方法访问 <code>SpanContext</code>,<code>SpanContext</code> 代表跨越进程边界,传递到下级Span的状态.(包含  <code>trace_id</code> <code>span_id</code> <code>sampled</code> 元组).</p>\n<p><code>SpanContext</code> 在跨越进程边界,和在追踪图中创建边界的时候会使用.</p>\n<h3 id=\"Logs\"><a href=\"#Logs\" class=\"headerlink\" title=\"Logs\"></a>Logs</h3><p> 每个<code>Span</code>可以进行多次Logs操作,每一次Logs操作, 都需要一个带<code>时间戳</code>的时间名称, 以及可选的任意大小的存储结构.<br><a href=\"https://github.com/opentracing/specification/blob/master/semantic_conventions.md#log-fields-table\">Standard LogKeys</a></p>\n<h3 id=\"Tags\"><a href=\"#Tags\" class=\"headerlink\" title=\"Tags\"></a>Tags</h3><p>每个 <code>Span</code> 可以有多个键值对(key:value)形式的<code>Tags</code>, <code>Tags</code>是没有时间戳的,支持简单的对<code>Span</code>进行注解和补充.</p>\n<p><a href=\"https://github.com/opentracing/specification/blob/master/semantic_conventions.md#span-tags-table\">Standard Tags</a></p>\n<h3 id=\"Baggage\"><a href=\"#Baggage\" class=\"headerlink\" title=\"Baggage\"></a>Baggage</h3><p><code>Baggage</code> 是存储在 <code>SpanContext</code> 中的一个键值对(SpanContext)集合. 它会在一条追踪链路上的所有span内全局传输. 在这种情况下, <code>Baggage</code>会随着Trace一同传播.(<code>Baggage</code>可理解为随着<code>trace</code>运行过程传送的行李).</p>\n<p><code>Baggage</code> 拥有强大功能,也会有很大的消耗.  由于Baggage的全局传输,如果包含的数量量太大，或者元素太多，它将降低系统的吞吐量或增加RPC的延迟.</p>\n<h3 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h3><p>Reference 有两种类型:</p>\n<ul>\n<li>ChildOf</li>\n<li>FollowsFrom</li>\n</ul>\n<hr>\n<p><a href=\"https://opentracing-contrib.github.io/opentracing-specification-zh/specification.html\">OpenTracing语义标准</a><br><a href=\"https://opentracing.io/specification/\">The OpenTracing Semantic Specification</a><br><a href=\"https://github.com/opentracing/specification/blob/master/specification.md\">The OpenTracing Semantic Specification-github</a></p>\n","text":"Spection Trace 语义Trace代表一个调用链. 通常， 一个 Trace 可以被理解为一系列span 组成的有向无环图(DAG), span 之间的边称为 Reference. SpanSpan 表示一个跨进程的 RPC 或者进程内部的一个过程. 每个span 可以...","link":"","photos":[],"count_time":{"symbolsCount":"1k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"微服务","slug":"微服务","count":2,"path":"api/tags/微服务.json"},{"name":"trace","slug":"trace","count":1,"path":"api/tags/trace.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Spection-Trace-%E8%AF%AD%E4%B9%89\"><span class=\"toc-text\">Spection  Trace 语义</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Trace\"><span class=\"toc-text\">Trace</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Span\"><span class=\"toc-text\">Span</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#SpanContext\"><span class=\"toc-text\">SpanContext</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Logs\"><span class=\"toc-text\">Logs</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Tags\"><span class=\"toc-text\">Tags</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Baggage\"><span class=\"toc-text\">Baggage</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Reference\"><span class=\"toc-text\">Reference</span></a></li></ol></li></ol>","author":{"name":"majm","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"技术分享","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Go源码-context","uid":"bd18eec6e0045068932a65759db44fe4","slug":"Go源码-context","date":"2022-08-30T15:39:07.000Z","updated":"2022-10-11T04:01:23.554Z","comments":true,"path":"api/articles/Go源码-context.json","keywords":null,"cover":[],"text":"在go服务器中,通常 每个传入的请求都会在自己的goroutine中进行处理. 请求处理程序通常会启动额外的goroutine来访问数据库 或者第三方服务.处理请求的一组goroutine通常需要访问特定于请求的值: 例如userid, request_id, token,tim...","link":"","photos":[],"count_time":{"symbolsCount":"19k","symbolsTime":"17 mins."},"categories":[],"tags":[{"name":"golang","slug":"golang","count":9,"path":"api/tags/golang.json"},{"name":"context","slug":"context","count":2,"path":"api/tags/context.json"},{"name":"源码剖析","slug":"源码剖析","count":1,"path":"api/tags/源码剖析.json"}],"author":{"name":"majm","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"技术分享","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"微服务:API Gateway","uid":"4d9104954e68f25499a2e47d5b935f32","slug":"微服务-API-Gateway","date":"2022-08-17T02:52:25.000Z","updated":"2022-08-29T08:55:33.248Z","comments":true,"path":"api/articles/微服务-API-Gateway.json","keywords":null,"cover":[],"text":"什么是 API网关API网关是一个服务器,是系统的唯一入口. 从面向对象设计的角度看，它与外观模式类似. API网关封装了系统内部架构,为每个客户端提供一个定制的API.它可能还具有其它职责,如身份验证、监控、负载均衡、缓存、协议转换、限流熔断、静态响应处理. API网关方式的核...","link":"","photos":[],"count_time":{"symbolsCount":952,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"微服务","slug":"微服务","count":2,"path":"api/tags/微服务.json"},{"name":"gateway","slug":"gateway","count":1,"path":"api/tags/gateway.json"}],"author":{"name":"majm","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"技术分享","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}